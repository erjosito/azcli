############################################################################
# Created by Jose Moreno
# October 2020
#
# The script creates a VWAN lab with
#  * 2 secure vhubs
#  * 2 branches connecting over VPN (simulated via Cisco CSR)
#
# CLI extensions required:
# * virtual-wan
# * azure-firewall
#
# Tested with zsh
############################################################################

###############
#  Variables  #
###############

# Control
no_of_hubs=2         # 1 or 2 hubs
no_of_spokes=2       # Number of spokes per hub (without counting the hub with NVA for indirect spokes)
secure_hub=no        # Whether firewalls are provisioned in the hubs
public_ip=no         # Whether extra VMs are created with public IP addressing
indirect_spokes=yes  # Whether spokes with Linux NVAs and indirect spokes are created
nva_bgp=yes          # If using an NVA in spoke14/24, whether configuring BGP on it towards VWAN
vnet_ass=default     # Route table to associate VNet connections. Can be 'default' or 'vnet'
vnet_prop=default    # Route table to propagate from VNet connections. Can be 'default', 'vnet' or 'none'
nva_in_hub1=yes      # Whether a Linux NVA is deployed in hub1 (note you need to have a valid NVA image in the same subscription!)
nva_in_hub2=yes      # Whether a Linux NVA is deployed in hub2 (note you need to have a valid NVA image in the same subscription!)
deploy_vpngw=no      # Whether VPN GWs should be deployed
deploy_er=yes        # Whether ER should be provided (note you need an account with a provider such as Megaport)
# Generic variables
rg=vwan
vwan=vwan
location1=westcentralus
location2=westcentralus
password=Microsoft123!
vwan_hub1_prefix=192.168.0.0/23
vwan_hub2_prefix=192.168.2.0/23
username=$(whoami)
vm_size=Standard_B1s
nva_size=Standard_B2ms
# Branches
publisher=cisco
offer=cisco-csr-1000v
sku=16_12-byol
version=$(az vm image list -p $publisher -f $offer -s $sku --all --query '[0].version' -o tsv)
branch1_prefix=10.201.0.0/24
branch1_prefix_long="10.201.0.0 255.255.255.0"
branch1_subnet=10.201.0.0/26
branch1_vm_subnet=10.201.0.64/26
branch1_gateway=10.201.0.1
branch1_bgp_ip=10.201.0.10
branch1_asn=65501
branch2_prefix=10.202.0.0/24
branch2_prefix_long="10.202.0.0 255.255.255.0"
branch2_vm_subnet=10.202.0.64/26
branch2_subnet=10.202.0.0/26
branch2_gateway=10.202.0.1
branch2_bgp_ip=10.202.0.10
branch2_2ary_bgp_ip=10.202.0.20
branch2_asn=65502
branch3_prefix=10.213.0.0/24
branch3_subnet=10.213.0.0/26
branch3_vm_subnet=10.213.0.64/26
branch3_gateway=10.213.0.1
branch3_bgp_ip=10.213.0.75
branch3_asn=65503
branch3_test_route=3.3.3.0/24
branch4_prefix=10.214.0.0/24
branch4_vm_subnet=10.214.0.64/26
branch4_subnet=10.214.0.0/26
branch4_gateway=10.214.0.1
branch4_bgp_ip=10.214.0.75
branch4_asn=65504
branch4_test_route=4.4.4.0/24
# ER (optional)
er_provider=Megaport
er_circuit_sku=Standard
megaport_script_location="/home/jose/repos/azcli/megaport.sh"
hub1_er_pop=Dallas
hub1_er_circuit_name="hub1er-$er_pop"
hub2_er_pop=Dallas
hub2_er_circuit_name="hub2er-$er_pop"
branch5_prefix=10.225.0.0/24
branch5_vm_subnet_name=vm
branch5_vm_subnet_prefix=10.225.0.64/26
branch5_gw_subnet_prefix=10.225.0.0/26
branch5_gw_name=branch5ergw
branch5_location=$location1

#############
# Functions #
#############

# Wait for resource to be created
function wait_until_finished {
     wait_interval=15
     resource_id=$1
     resource_name=$(echo $resource_id | cut -d/ -f 9)
     echo "Waiting for resource $resource_name to finish provisioning..."
     start_time=`date +%s`
     state=$(az resource show --id $resource_id --query properties.provisioningState -o tsv)
     until [[ "$state" == "Succeeded" ]] || [[ "$state" == "Failed" ]] || [[ -z "$state" ]]
     do
        sleep $wait_interval
        state=$(az resource show --id $resource_id --query properties.provisioningState -o tsv)
     done
     if [[ -z "$state" ]]
     then
        echo "Something really bad happened..."
     else
        run_time=$(expr `date +%s` - $start_time)
        ((minutes=${run_time}/60))
        ((seconds=${run_time}%60))
        echo "Resource $resource_name provisioning state is $state, wait time $minutes minutes and $seconds seconds"
     fi
}

# Helper function to calculate the default gateway for a subnet
# Example: default_gw 172.16.1.31 255.255.255.248
function default_gw(){
    IP=$1
    MASK=$2
    DEBUG=$3    # Set to yes for message debugging
    IP_HEX=$(printf '%.2X%.2X%.2X%.2X\n' `echo $IP | sed -e 's/\./ /g'`)
    MASK_HEX=$(printf '%.2X%.2X%.2X%.2X\n' `echo $MASK | sed -e 's/\./ /g'`)
    IP_DEC=$(echo "ibase=16; $IP_HEX" | bc)
    MASK_DEC=$(echo "ibase=16; $MASK_HEX" | bc)
    SUBNET_DEC=$(( IP_DEC&MASK_DEC ))
    GW_DEC=$(( $SUBNET_DEC + 1 ))
    GW_HEX=$(printf '%x\n' $GW_DEC)
    if [[ "${#GW_HEX}" == "7" ]]; then
        GW_HEX="0${GW_HEX}"
    fi
    GW=$(printf '%d.%d.%d.%d\n' `echo $GW_HEX | sed -r 's/(..)/0x\1 /g'`)
    if [[ "$DEBUG" == "yes" ]]
    then
        echo "Input: ${IP}/${MASK}"
        echo "Decimal: ${IP_DEC}/${MASK_DEC}"
        echo "Subnet decimal: ${SUBNET_DEC}"
        echo "Gateway dec: ${GW_DEC}"
        echo "Gateway hex: ${GW_HEX}"
        echo "Gateway: ${GW}"
    else
        echo "$GW"
    fi
}

# Create a VNet with a test VM and optionally attach it to a hub
function create_spoke() {
    hub=$1
    spoke=$2
    if [[ -z "$hub" ]] || [[ -z "spoke" ]]
    then
        echo "You need to provide a hub ID and a spoke ID"
        exit
    fi
    connect_to_hub=$3
    if [[ -z "$connect_to_hub" ]]
    then
        connect_to_hub="yes"
    fi
    spoke_id="${hub}${spoke}"
    hub_name="hub${hub}"
    vnet_prefix="10.${hub}.${spoke}.0/24"
    subnet_prefix="10.${hub}.${spoke}.0/26"
    if [[ "$hub" == "1" ]]
    then
        location="$location1"
        nsg_name="$nsg1_name"
        hub_vnet_ass_rt_id="$hub1_vnet_ass_rt_id"
        hub_vnet_prop_rt_id="$hub1_vnet_prop_rt_id"
    elif [[ "$hub" == "2" ]]
    then
        location="$location2"
        nsg_name="$nsg2_name"
        hub_vnet_ass_rt_id="$hub2_vnet_ass_rt_id"
        hub_vnet_prop_rt_id="$hub2_vnet_prop_rt_id"
    else
        echo "ERROR: $hub is not a valid hub ID"
        exit
    fi
    echo "Creating VM spoke${spoke_id}-vm in VNet spoke${spoke_id}-$location..."
    az vm create -n spoke${spoke_id}-vm -g $rg -l $location --image ubuntuLTS --admin-username $username --generate-ssh-keys \
        --public-ip-address spoke${spoke_id}-pip --vnet-name spoke${spoke_id}-$location --nsg $nsg_name --size $vm_size \
        --vnet-address-prefix $vnet_prefix --subnet vm --subnet-address-prefix $subnet_prefix --custom-data $cloudinit_file -o none
    echo "Installing Network Watcher extension in VM spoke${spoke_id}-vm..."
    az vm extension set --vm-name spoke${spoke_id}-vm -g $rg -n NetworkWatcherAgentLinux --publisher Microsoft.Azure.NetworkWatcher --version 1.4 -o none
    if [[ "$connect_to_hub" == "yes" ]]
    then
        echo "Connecting VNet spoke${spoke_id} to $hub_name..."
        az network vhub connection create -n spoke${spoke_id} -g $rg --vhub-name $hub_name --remote-vnet spoke${spoke_id}-$location \
            --internet-security true --associated-route-table $hub_vnet_ass_rt_id --propagated-route-tables $hub_vnet_prop_rt_id --labels $vnet_prop_label -o none
    else
        echo "Skipping connection to the hub"
    fi
}

# Create a linux VM to simulate a branch to connect to an NVA deployed in the hub
function create_hub_nva_branch() {
    hub_id=$1
    hub_name="hub${hub_id}"
    nva_name="${hub_name}nva"
    nva_asn="6510${hub_id}"
    # Set variables depending on which hub we are connecting the branch to
    if [[ "$hub_id" == "1" ]]
    then
        onprem_vnet_name=branch3
        onprem_vnet_prefix=$branch3_prefix
        onprem_nva_subnet_name=onpremnva
        onprem_nva_subnet_prefix=$branch3_vm_subnet
        onprem_linuxnva_asn=${branch3_asn}
        onprem_linuxnva_name=branch3-nva
        onprem_linuxnva_pip=${onprem_linuxnva_name}-pip
        onprem_linuxnva_ip=$branch3_bgp_ip
        onprem_test_route=$branch3_test_route
        vhub_space="$vwan_hub1_prefix"
        location=$location1
        storage_account_name=$storage_account1_name
    else
        onprem_vnet_name=branch4
        onprem_vnet_prefix=$branch4_prefix
        onprem_nva_subnet_name=onpremnva
        onprem_nva_subnet_prefix=$branch4_vm_subnet
        onprem_linuxnva_asn=${branch4_asn}
        onprem_linuxnva_name=branch4-nva
        onprem_linuxnva_pip=${onprem_linuxnva_name}-pip
        onprem_linuxnva_ip=$branch4_bgp_ip
        onprem_test_route=$branch4_test_route
        vhub_space="$vwan_hub2_prefix"
        location=$location2
        storage_account_name=$storage_account2_name
    fi
    # Get RS values from the virtual hub
    echo "Getting IP addresses and ASN from ${hub_name}..."
    rs_ip1=$(az network vhub show -n $hub_name -g $rg --query 'virtualRouterIps[0]' -o tsv) && echo $rs_ip1
    rs_ip2=$(az network vhub show -n $hub_name -g $rg --query 'virtualRouterIps[1]' -o tsv) && echo $rs_ip2
    rs_asn=$(az network vhub show -n $hub_name -g $rg --query 'virtualRouterAsn' -o tsv) && echo $rs_asn
    # Create VNet
    echo "Creating VNet $onprem_vnet_name with $onprem_vnet_prefix..."
    az network vnet create -n $onprem_vnet_name -g $rg --address-prefixes $onprem_vnet_prefix --subnet-name $onprem_nva_subnet_name --subnet-prefixes $onprem_nva_subnet_prefix -o none
    # Cloudinit file for onprem NVA
    linuxnva_cloudinit_file=/tmp/linuxnva_cloudinit.txt
    cat <<EOF > $linuxnva_cloudinit_file
#cloud-config
runcmd:
  - apt update && apt install -y bird strongswan
  - sysctl -w net.ipv4.ip_forward=1
  - sysctl -w net.ipv4.conf.all.accept_redirects = 0 
  - sysctl -w net.ipv4.conf.all.send_redirects = 0
EOF
    # NSG for onprem NVA
    echo "Creating NSG ${onprem_linuxnva_name}-nsg..."
    az network nsg create -n "${onprem_linuxnva_name}-nsg" -g $rg -o none
    az network nsg rule create -n SSH --nsg-name "${onprem_linuxnva_name}-nsg" -g $rg --priority 1000 --destination-port-ranges 22 --access Allow --protocol Tcp -o none
    az network nsg rule create -n IKE --nsg-name "${onprem_linuxnva_name}-nsg" -g $rg --priority 1010 --destination-port-ranges 4500 --access Allow --protocol Udp -o none
    az network nsg rule create -n IPsec --nsg-name "${onprem_linuxnva_name}-nsg" -g $rg --priority 1020 --destination-port-ranges 500 --access Allow --protocol Udp -o none
    az network nsg rule create -n ICMP --nsg-name "${onprem_linuxnva_name}-nsg" -g $rg --priority 1030 --destination-port-ranges '*' --access Allow --protocol Icmp -o none
    az network watcher flow-log create -l $location -n ${onprem_linuxnva_name}-nsg -g $rg \
        --nsg ${onprem_linuxnva_name}-nsg --storage-account $storage_account_name --log-version 2 --retention 7 -o none
    # VM for onprem NVA
    echo "Creating VM $onprem_linuxnva_name..."
    az vm create -n $onprem_linuxnva_name -g $rg -l $location --image ubuntuLTS --generate-ssh-keys \
        --public-ip-address $onprem_linuxnva_pip --vnet-name $onprem_vnet_name --size $vm_size --subnet $onprem_nva_subnet_name \
        --custom-data $linuxnva_cloudinit_file --private-ip-address "$onprem_linuxnva_ip" --nsg "${onprem_linuxnva_name}-nsg" -o none
    onprem_linuxnva_nic_id=$(az vm show -n $onprem_linuxnva_name -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
    az network nic update --ids $onprem_linuxnva_nic_id --ip-forwarding -o none
    echo "Getting information about the created VM..."
    onprem_linuxnva_pip_ip=$(az network public-ip show -n $onprem_linuxnva_pip -g $rg --query ipAddress -o tsv) && echo $onprem_linuxnva_pip_ip
    onprem_linuxnva_private_ip=$(az network nic show --ids $onprem_linuxnva_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv) && echo $onprem_linuxnva_private_ip
    onprem_linuxnva_default_gw=$(default_gw "$onprem_linuxnva_ip" "255.255.255.192") && echo $onprem_linuxnva_default_gw
    # Public IPs of the external interfaces of the VWAN NVAs
    echo "Getting public IPs of the NVA $nva_name deployed in the virtual hub..."
    pip1=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[1].publicIpAddress' -o tsv) && echo $pip1
    pip2=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[3].publicIpAddress' -o tsv) && echo $pip2
    # Private IPs of the external interfaces of the VWAN NVAs
    echo "Getting private IPs (external NICs) of the NVA $nva_name deployed in the virtual hub..."
    nva_ip21=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[1].privateIpAddress' -o tsv) && echo $nva_ip21
    nva_ip22=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[3].privateIpAddress' -o tsv) && echo $nva_ip22
    # Private IPs VWAN NVAs
    echo "Getting private IPs (internal NICs) of the NVA $nva_name deployed in the virtual hub..."
    nva_private_ip11=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[0].privateIpAddress' -o tsv) && echo $nva_private_ip11
    nva_private_ip12=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[2].privateIpAddress' -o tsv) && echo $nva_private_ip12
    # Gateway for the VWAN NVA (internal NIC)
    nva_internal_mask=$(ssh -n -o StrictHostKeyChecking=no -o BatchMode=yes "$pip1" "ifconfig eth1 | grep netmask | sed -n 's/.* netmask \([^ ]*\).*/\1/p'") && echo "Network mask $nva_internal_mask"
    if [[ "${nva_internal_mask:0:11}" != "255.255.255" ]]
    then
        echo "It looks like $nva_internal_mask is not a correct network mask, defaulting to 255.255.255.240..."
        nva_internal_mask="255.255.255.240"
    fi
    nva_default_gw=$(default_gw "$nva_private_ip11" "$nva_internal_mask") && echo "Internal gateway $nva_default_gw"
    # Private/public endpoints (A/B are the redundant hub NVAs, C is onprem)
    endpoint_a_public=$pip1
    endpoint_a_private=$nva_ip21
    endpoint_b_public=$pip2
    endpoint_b_private=$nva_ip22
    endpoint_c_public=$onprem_linuxnva_pip_ip
    endpoint_c_private=$onprem_linuxnva_private_ip
    echo "Configuring VPN between A:${endpoint_a_public}/${endpoint_a_private} and C:${endpoint_c_public}/${endpoint_c_private}"
    echo "Configuring VPN between B:${endpoint_b_public}/${endpoint_b_private} and C:${endpoint_c_public}/${endpoint_c_private}"
    # Initial config: NVA 0
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip1 "sudo ip route add $vhub_space via $nva_default_gw"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip1 "sudo ip tunnel add vti0 local $endpoint_a_private remote $endpoint_c_public mode vti key 11"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip1 "sudo sysctl -w net.ipv4.conf.vti0.disable_policy=1"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip1 "sudo ip link set up dev vti0"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip1 "sudo ip route add ${endpoint_c_private}/32 dev vti0"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip1 "sudo sed -i 's/# install_routes = yes/install_routes = no/' /etc/strongswan.d/charon.conf"
    # Initial config: NVA 1
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip2 "sudo ip route add $vhub_space via $nva_default_gw"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip2 "sudo ip tunnel add vti0 local $endpoint_b_private remote $endpoint_c_public mode vti key 11"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip2 "sudo sysctl -w net.ipv4.conf.vti0.disable_policy=1"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip2 "sudo ip link set up dev vti0"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip2 "sudo ip route add ${endpoint_c_private}/32 dev vti0"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip2 "sudo sed -i 's/# install_routes = yes/install_routes = no/' /etc/strongswan.d/charon.conf"
    # Initial config: Onprem
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo ip tunnel add vti0 local $endpoint_c_private remote $endpoint_a_public mode vti key 11"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo sysctl -w net.ipv4.conf.vti0.disable_policy=1"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo ip link set up dev vti0"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo ip route add ${nva_ip21}/32 dev vti0"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo ip tunnel add vti1 local $endpoint_c_private remote $endpoint_b_public mode vti key 12"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo sysctl -w net.ipv4.conf.vti1.disable_policy=1"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo ip link set up dev vti1"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo ip route add ${nva_ip22}/32 dev vti1"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo sed -i 's/# install_routes = yes/install_routes = no/' /etc/strongswan.d/charon.conf"
    # IPsec Config files
    vpn_psk=$(openssl rand -base64 64)
    vpn_psk=${vpn_psk//$'\n'/}  # Remove line breaks
    psk_file_a=/tmp/ipsec.secrets.a
    psk_file_b=/tmp/ipsec.secrets.b
    psk_file_c=/tmp/ipsec.secrets.c
    # PSK VWAN NVA 0
    cat <<EOF > $psk_file_a
$endpoint_a_public $endpoint_c_public : PSK "$vpn_psk"
EOF
    # PSK VWAN NVA 1
    cat <<EOF > $psk_file_b
$endpoint_b_public $endpoint_c_public : PSK "$vpn_psk"
EOF
    # PSK onprem
    cat <<EOF > $psk_file_c
$endpoint_c_public $endpoint_a_public : PSK "$vpn_psk"
$endpoint_c_public $endpoint_b_public : PSK "$vpn_psk"
EOF
    ipsec_file_a=/tmp/ipsec.conf.a
    ipsec_file_b=/tmp/ipsec.conf.b
    ipsec_file_c=/tmp/ipsec.conf.c
    cat <<EOF > $ipsec_file_a
config setup
        charondebug="all"
        uniqueids=yes
        strictcrlpolicy=no
conn to-onprem
  authby=secret
  leftid=$endpoint_a_public
  leftsubnet=0.0.0.0/0
  right=$endpoint_c_public
  rightsubnet=0.0.0.0/0
  ike=aes256-sha2_256-modp1024!
  esp=aes256-sha2_256!
  keyingtries=0
  ikelifetime=1h
  lifetime=8h
  dpddelay=30
  dpdtimeout=120
  dpdaction=restart
  auto=start
  mark=11
EOF
    # IPsec VWAN NVA 1
    cat <<EOF > $ipsec_file_b
config setup
        charondebug="all"
        uniqueids=yes
        strictcrlpolicy=no
conn to-onprem
  authby=secret
  leftid=$endpoint_b_public
  leftsubnet=0.0.0.0/0
  right=$endpoint_c_public
  rightsubnet=0.0.0.0/0
  ike=aes256-sha2_256-modp1024!
  esp=aes256-sha2_256!
  keyingtries=0
  ikelifetime=1h
  lifetime=8h
  dpddelay=30
  dpdtimeout=120
  dpdaction=restart
  auto=start
  mark=11
EOF
    # IPsec onprem
    cat <<EOF > $ipsec_file_c
config setup
        charondebug="all"
        uniqueids=yes
        strictcrlpolicy=no
conn to-azure1
  authby=secret
  leftid=$endpoint_c_public
  leftsubnet=0.0.0.0/0
  right=$endpoint_a_public
  rightsubnet=0.0.0.0/0
  ike=aes256-sha2_256-modp1024!
  esp=aes256-sha2_256!
  keyingtries=0
  ikelifetime=1h
  lifetime=8h
  dpddelay=30
  dpdtimeout=120
  dpdaction=restart
  auto=start
  mark=11
conn to-azure2
  authby=secret
  leftid=$endpoint_c_public
  leftsubnet=0.0.0.0/0
  right=$endpoint_b_public
  rightsubnet=0.0.0.0/0
  ike=aes256-sha2_256-modp1024!
  esp=aes256-sha2_256!
  keyingtries=0
  ikelifetime=1h
  lifetime=8h
  dpddelay=30
  dpdtimeout=120
  dpdaction=restart
  auto=start
  mark=12
EOF
    username=$(whoami)
    # Deploy files to NVA1
    scp $psk_file_a $pip1:/home/$username/ipsec.secrets
    scp $ipsec_file_a $pip1:/home/$username/ipsec.conf
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip1 "sudo mv ./ipsec.* /etc/"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip1 "sudo systemctl restart ipsec"
    # Deploy files to NVA2
    scp $psk_file_b $pip2:/home/$username/ipsec.secrets
    scp $ipsec_file_b $pip2:/home/$username/ipsec.conf
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip2 "sudo mv ./ipsec.* /etc/"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip2 "sudo systemctl restart ipsec"
    # Deploy files to onprem
    scp $psk_file_c $onprem_linuxnva_pip_ip:/home/$username/ipsec.secrets
    scp $ipsec_file_c $onprem_linuxnva_pip_ip:/home/$username/ipsec.conf
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo mv ./ipsec.* /etc/"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo systemctl restart ipsec"
    # Configure BGP with Bird
    # =======================
    bird_config_file_a=/tmp/bird.conf.a  # NVA 1/2
    bird_config_file_c=/tmp/bird.conf.c  # onprem
    # BGP config VWAN NVA (both instances)
    cat <<EOF > $bird_config_file_a
log syslog all;
protocol device {
        scan time 10;
}
protocol direct {
      disabled;
}
protocol kernel {
      preference 254;
      learn;
      merge paths on;
      import filter {
          if net ~ ${endpoint_c_private}/32 then accept;
          else reject;
      };
      export filter {
          if net ~ ${endpoint_c_private}/32 then reject;
          if net ~ [ 0.0.0.0/0{0,1} ] then reject;
          else accept;
      };
}
protocol static {
      import all;
      route $vhub_space via $nva_default_gw;
}
filter DROP_LONG {
      # Drop long prefixes
      if ( net ~ [ 0.0.0.0/0{30,32} ] ) then { reject; }
      else accept;
}
protocol bgp RS1 {
      description "RS1";
      multihop;
      local as $nva_asn;
      neighbor $rs_ip1 as $rs_asn;
          import filter {accept;};
          # export filter {accept;};
          export filter DROP_LONG;
}
protocol bgp RS2 {
      description "RS1";
      multihop;
      local as $nva_asn;
      neighbor $rs_ip2 as $rs_asn;
          import filter {accept;};
          # export filter {accept;};
          export filter DROP_LONG;
}
protocol bgp onprem {
      description "BGP to Onprem";
      multihop;
      local as $nva_asn;
      neighbor $endpoint_c_private as $onprem_linuxnva_asn;
          import filter {accept;};
          # export filter {accept;};
          export filter DROP_LONG;
}
EOF
    # Configure BGP with Bird (onprem)
    cat <<EOF > $bird_config_file_c
log syslog all;
router id $endpoint_c_private;
protocol device {
        scan time 10;
}
protocol direct {
      disabled;
}
protocol kernel {
      preference 254;
      learn;
      merge paths on;
      import filter {
          if net ~ ${nva_ip21}/32 then accept;
          if net ~ ${nva_ip22}/32 then accept;
          else reject;
      };
      export filter {
          if net ~ ${nva_ip21}/32 then reject;
          if net ~ ${nva_ip22}/32 then reject;
          if net ~ [ 0.0.0.0/0{0,1} ] then reject;
          else accept;
      };
}
protocol static {
      import all;
      route $onprem_test_route via $onprem_linuxnva_default_gw;
      route $onprem_vnet_prefix via $onprem_linuxnva_default_gw;
}
filter DROP_LONG {
      # Drop long prefixes
      if ( net ~ [ 0.0.0.0/0{30,32} ] ) then { reject; }
      else accept;
}
protocol bgp NVA1 {
      description "BGP to NVA1";
      multihop;
      local $endpoint_c_private as $onprem_linuxnva_asn;
      neighbor $endpoint_a_private as $nva_asn;
          import filter {accept;};
          #export filter {accept;};
          export filter DROP_LONG;
}
protocol bgp NVA2 {
      description "BGP to NVA2";
      multihop;
      local $endpoint_c_private as $onprem_linuxnva_asn;
      neighbor $endpoint_b_private as $nva_asn;
          import filter {accept;};
          #export filter {accept;};
          export filter DROP_LONG;
}
EOF
    # Deploy BGP config files
    username=$(whoami)
    # NVA instance 0
    scp $bird_config_file_a "${pip1}:/home/${username}/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip1 "sudo mv /home/${username}/bird.conf /etc/bird/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip1 "sudo systemctl restart bird"
    # NVA instance 1
    scp $bird_config_file_a "${pip2}:/home/${username}/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip2 "sudo mv /home/${username}/bird.conf /etc/bird/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $pip2 "sudo systemctl restart bird"
    # Onprem
    scp $bird_config_file_c "${onprem_linuxnva_pip_ip}:/home/${username}/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo mv /home/${username}/bird.conf /etc/bird/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo systemctl restart bird"
    # Some diagnostics
    echo "IPSec status in onprem NVA:"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo ipsec status"
    echo "BGP peerings in onprem NVA:"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $onprem_linuxnva_pip_ip "sudo birdc show protocols"
}

# Create a Linux NVA in the hub
# Most code from nva_vwan.azcli in this repo
function create_hub_nva() {
    hub_id=$1
    hub_name="hub${hub_id}"
    subscription_id=$(az account show --query id -o tsv)
    vendor="Jose_generic_test_nva"
    version=latest
    deploy_mode=rest        # arm and rest supported at this time
    vpn_endpoint=public     # if "private", deploys ER to connect to onprem too. Use "public" if you dont have access to ER
    nva_name="${hub_name}nva"
    nva_asn="6510${hub_id}"
    gnva_cloudinit="/tmp/nva-cloudinit.txt"
    username=$(whoami)
    public_ssh_key=$(more ~/.ssh/id_rsa.pub)
    # Verify subscription ID
    if [[ "$subscription_id" != "e7da9914-9b05-4891-893c-546cb7b0422e" ]]
    then
        "ERROR: $subscription_id is not a valid subscription for NVA $vendor"
        exit
    fi
    # Get IDs
    vwan_id=$(az network vwan show -n $vwan -g $rg --query name -o tsv)
    hub_arm_id=$(az network vhub show -n $hub_name -g $rg --query id -o tsv)
    # Create cloudinit file
    cat <<EOF > $gnva_cloudinit
#cloud-config
users:
  - default
  - name: $username
    sudo: ["ALL=(ALL) NOPASSWD:ALL"]
    ssh-authorized-keys:
     - $public_ssh_key
packages:
  - jq
runcmd:
  - apt update
  - UCF_FORCE_CONFOLD=1 DEBIAN_FRONTEND=noninteractive apt install -y bird strongswan
  - sysctl -w net.ipv4.ip_forward=1
  - sysctl -w net.ipv4.conf.all.accept_redirects = 0 
  - sysctl -w net.ipv4.conf.all.send_redirects = 0
EOF
    cloudinit_string=$(cat $gnva_cloudinit | python3 -c 'import json, sys; print( json.dumps( sys.stdin.read() ) )')
    # REST payload
    json_payload='{
        "properties": {
        "nvaSku": {
                "vendor": "'$vendor'",
                "bundledScaleUnit": "2",
                "marketPlaceVersion": "'$version'"
        },
        "virtualHub": {
                "id": "'$hub_arm_id'"
        },
        "virtualApplianceAsn": '$nva_asn',
        "cloudInitConfiguration": '$cloudinit_string'
        },
        "location": "'$location'",
        "tags": {
        "tagexample1": "tagvalue1"
        }
    }'
    uri="/subscriptions/${subscription_id}/resourceGroups/${rg}/providers/Microsoft.Network/NetworkVirtualAppliances/${nva_name}?api-version=2021-02-01"
    echo "Sending REST request to $uri..."
    az rest --method PUT --uri $uri --body "$json_payload" -o none
    nva_id=$(az network virtual-appliance show -n $nva_name -g $rg --query id -o tsv)
    wait_until_finished $nva_id
    # Diagnostics
    echo "Interfaces in the NVA instances..."
    nva_pip1=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[1].publicIpAddress' -o tsv) && echo $pip1
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no "$nva_pip1" "ip a"
    nva_pip2=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[3].publicIpAddress' -o tsv) && echo $pip2
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no "$nva_pip2" "ip a"
}

# Configure BGP in a hub NVA
function configure_hub_nva_bgp() {
    hub_id=$1
    hub_name="hub${hub_id}"
    nva_name="${hub_name}nva"
    echo "Getting public IP addresses of NVA $nva_name..."
    nva_pip1=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[1].publicIpAddress' -o tsv) && echo $pip1
    nva_pip2=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[3].publicIpAddress' -o tsv) && echo $pip2
    # Get RS IPs
    echo "Finding information about Route Service in $hub_name..."
    rs_ip1=$(az network vhub show -n $hub_name -g $rg --query 'virtualRouterIps[0]' -o tsv) && echo $rs_ip1
    rs_ip2=$(az network vhub show -n $hub_name -g $rg --query 'virtualRouterIps[1]' -o tsv) && echo $rs_ip2
    rs_asn=$(az network vhub show -n $hub_name -g $rg --query 'virtualRouterAsn' -o tsv) && echo $rs_asn
    # Get NVA private IPs
    echo "Finding internal private IPs of NVA $nva_name..."
    nva_ip1=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[0].privateIpAddress' -o tsv) && echo $nva_ip1
    nva_ip2=$(az network virtual-appliance show -n $nva_name -g $rg --query 'virtualApplianceNics[2].privateIpAddress' -o tsv) && echo $nva_ip2
    # Find out the gateway for the private ip
    nva_internal_mask=$(ssh -n -o StrictHostKeyChecking=no -o BatchMode=yes "$nva_pip1" "ifconfig eth1 | grep netmask | sed -n 's/.* netmask \([^ ]*\).*/\1/p'") && echo "Network mask $nva_internal_mask"
    if [[ "${nva_internal_mask:0:11}" != "255.255.255" ]]
    then
        echo "It looks like $nva_internal_mask is not a correct network mask, defaulting to 255.255.255.240..."
        nva_internal_mask="255.255.255.240"
    fi
    nva_default_gw=$(default_gw "$nva_ip1" "$nva_internal_mask") && echo "Internal gateway is $nva_default_gw"
    # Adding static IP routes
    if [[ $hub_id == "1" ]]
    then
        vhub_space="$vwan_hub1_prefix"
    else
        vhub_space="$vwan_hub2_prefix"
    fi
    echo "Adding static routes to NVA instances for the hub prefix $vhub_space..."
    ssh -n -o StrictHostKeyChecking=no -o BatchMode=yes "$nva_pip1" "sudo ip route add $vhub_space via $nva_default_gw"
    ssh -n -o StrictHostKeyChecking=no -o BatchMode=yes "$nva_pip2" "sudo ip route add $vhub_space via $nva_default_gw"
    # Create BGP file
    bird_config_file=/tmp/bird.conf
    echo "Generating BIRD config file in $bird_config_file..."
    cat <<EOF > $bird_config_file
log syslog all;
#router id $nva_ip1;
protocol device {
        scan time 10;
}
protocol direct {
      disabled;
}
protocol kernel {
      preference 254;
      learn;
      merge paths on;
      export all;
      #disabled;
}
protocol static {
      import all;
      # route $vhub_space via $linuxnva_default_gw;
}
filter DROP_LONG {
      # Drop long prefixes
      if ( net ~ [ 0.0.0.0/0{30,32} ] ) then { reject; }
      else accept;
}
protocol bgp RS1 {
      description "RS1";
      multihop;
      #local $nva_ip1 as $nva_asn;
      local as $nva_asn;
      neighbor $rs_ip1 as $rs_asn;
          import filter {accept;};
          # export filter {accept;};
          export filter DROP_LONG;
}
protocol bgp RS2 {
      description "RS1";
      multihop;
      #local $nva_ip1 as $nva_asn;
      local as $nva_asn;
      neighbor $rs_ip2 as $rs_asn;
          import filter {accept;};
          # export filter {accept;};
          export filter DROP_LONG;
}
EOF
    # Deploy file
    echo "Copying BIRD configuration files to both NVA instances..."
    username=$(whoami)
    scp $bird_config_file "${nva_pip1}:/home/${username}/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva_pip1 "sudo mv /home/${username}/bird.conf /etc/bird/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva_pip1 "sudo systemctl restart bird"
    scp $bird_config_file "${nva_pip2}:/home/${username}/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva_pip2 "sudo mv /home/${username}/bird.conf /etc/bird/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva_pip2 "sudo systemctl restart bird"
    # Diagnostics
    echo "Running some quick BGP diagnostics on both NVA instances..."
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva_pip1 "sudo birdc show prot"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva_pip2 "sudo birdc show prot"
}

#############
#   Start   #
#############

# Start: create RG
az group create -n $rg -l $location1

# vwan and hubs
echo "Creating Virtual WAN and Virtual Hubs..."
az network vwan create -n $vwan -g $rg -l $location1 --branch-to-branch-traffic true --type Standard -o none
az network vhub create -n hub1 -g $rg --vwan $vwan -l $location1 --address-prefix $vwan_hub1_prefix -o none
if [[ "$no_of_hubs" == "2" ]]
then
    az network vhub create -n hub2 -g $rg --vwan $vwan -l $location2 --address-prefix $vwan_hub2_prefix -o none
fi

# Create RT for vnets
echo "Creating custom RT for VNets..."
az network vhub route-table create -n hub1Vnet --vhub-name hub1 -g $rg --labels vnet -o none
if [[ "$no_of_hubs" == "2" ]]
then
    az network vhub route-table create -n hub2Vnet --vhub-name hub2 -g $rg --labels vnet -o none
fi

# Add nohub1/nohub2 labels to default RTs
# az network vhub route-table update -n defaultRouteTable --vhub-name hub1 -g $rg --labels default nohub2
# az network vhub route-table update -n defaultRouteTable --vhub-name hub2 -g $rg --labels default nohub1

# Retrieve IDs of RTs. We will need this when creating the connections
hub1_vnet_rt_id=$(az network vhub route-table show --vhub-name hub1 -g $rg -n hub1Vnet --query id -o tsv)
hub1_default_rt_id=$(az network vhub route-table show --vhub-name hub1 -g $rg -n defaultRouteTable --query id -o tsv)
hub1_none_rt_id=$(az network vhub route-table show --vhub-name hub1 -g $rg -n noneRouteTable --query id -o tsv)
if [[ "$no_of_hubs" == "2" ]]
then
    hub2_default_rt_id=$(az network vhub route-table show --vhub-name hub2 -g $rg -n defaultRouteTable --query id -o tsv)
    hub2_vnet_rt_id=$(az network vhub route-table show --vhub-name hub2 -g $rg -n hub2Vnet --query id -o tsv)
    hub2_none_rt_id=$(az network vhub route-table show --vhub-name hub2 -g $rg -n noneRouteTable --query id -o tsv)
fi

# Define which association/propagations we will use
if [[ "$vnet_ass" == "vnet" ]]
then
    hub1_vnet_ass_rt_id="$hub1_vnet_rt_id"
    hub2_vnet_ass_rt_id="$hub2_vnet_rt_id"
else
    hub1_vnet_ass_rt_id="$hub1_default_rt_id"
    hub2_vnet_ass_rt_id="$hub2_default_rt_id"
fi
if [[ "$vnet_prop" == "vnet" ]]
then
    hub1_vnet_prop_rt_id="$hub1_vnet_rt_id"
    hub2_vnet_prop_rt_id="$hub2_vnet_rt_id"
    vnet_prop_label='vnet'
elif [[ "$vnet_prop" == "none" ]]
then
    hub1_vnet_prop_rt_id="$hub1_none_rt_id"
    hub2_vnet_prop_rt_id="$hub2_none_rt_id"
    vnet_prop_label='none'
else
    hub1_vnet_prop_rt_id="$hub1_default_rt_id"
    hub2_vnet_prop_rt_id="$hub2_default_rt_id"
    vnet_prop_label="default"
fi


# Create VPN gateways (not using --no-wait to avoid race conditions due to parallelism)
if [[ "$deploy_vpngw" == "yes" ]]
then
    echo "Creating VPN Gateways..."
    az network vpn-gateway create -n hubvpn1 -g $rg -l $location1 --vhub hub1 --asn 65515 -o none
    if [[ "$no_of_hubs" == "2" ]]
    then
        az network vpn-gateway create -n hubvpn2 -g $rg -l $location2 --vhub hub2 --asn 65515 -o none
    fi
fi

# Create NSGs to be used by VMs
echo "Creating NSGs for Virtual Machines..."
nsg1_name=vm-nsg-$location1
az network nsg create -n $nsg1_name -g $rg -l $location1 -o none
az network nsg rule create --nsg-name $nsg1_name -g $rg -n Allow_Inbound_SSH --priority 1000 \
    --access Allow --protocol Tcp --source-address-prefixes '*' --direction Inbound \
    --destination-address-prefixes '*' --destination-port-ranges 22 -o none
az network nsg rule create --nsg-name $nsg1_name -g $rg -n Allow_Inbound_HTTP --priority 1010 --direction Inbound \
    --access Allow --protocol Tcp --source-address-prefixes '10.0.0.0/8' '172.16.0.0/12' '20.0.0.0/6' '192.168.0.0/16' \
    --destination-address-prefixes '*' --destination-port-ranges 9 80 443 -o none
# az network nsg rule create --nsg-name $nsg1_name -g $rg -n Allow_Inbound_HTTP_Return --priority 1015 --direction Inbound \
#     --access Allow --protocol Tcp --source-address-prefixes '*' \
#     --destination-address-prefixes '10.0.0.0/8' '172.16.0.0/12' '20.0.0.0/6' '192.168.0.0/16' --destination-port-ranges 80 443
az network nsg rule create --nsg-name $nsg1_name -g $rg -n Allow_Inbound_IPsec --priority 1020 \
    --access Allow --protocol Udp --source-address-prefixes 'Internet' --direction Inbound \
    --destination-address-prefixes '*' --destination-port-ranges 500 4500 -o none
az network nsg rule create --nsg-name $nsg1_name -g $rg -n Allow_Inbound_NTP --priority 1030 \
    --access Allow --protocol Udp --source-address-prefixes '10.0.0.0/8' '172.16.0.0/12' '20.0.0.0/6' '192.168.0.0/16' --direction Inbound \
    --destination-address-prefixes '*' --destination-port-ranges 123 -o none
az network nsg rule create --nsg-name $nsg1_name -g $rg -n Allow_Inbound_Icmp --priority 1040 \
    --access Allow --protocol Icmp --source-address-prefixes '*' --direction Inbound \
    --destination-address-prefixes '*' --destination-port-ranges '*' -o none
az network nsg rule create --nsg-name $nsg1_name -g $rg -n Allow_Outbound_All --priority 1000 \
    --access Allow --protocol '*' --source-address-prefixes '*' --direction Outbound \
    --destination-address-prefixes '*' --destination-port-ranges '*' -o none
# Configure NSG flow logs
storage_account1_name=vwan$RANDOM$location1
az storage account create -n $storage_account1_name -g $rg --sku Standard_LRS --kind StorageV2 -l $location1 -o none
az network watcher flow-log create -l $location1 -n flowlog-$location1 -g $rg \
    --nsg $nsg1_name --storage-account $storage_account1_name --log-version 2 --retention 7 -o none

# Hub2
if [[ "$no_of_hubs" == "2" ]]
then
    nsg2_name=vm-nsg-$location2
    if [[ "$location1" != "$location2" ]]
    then
        az network nsg create -n $nsg2_name -g $rg -l $location2 -o none
        az network nsg rule create --nsg-name $nsg2_name -g $rg -n Allow_Inbound_SSH --priority 1000 \
            --access Allow --protocol Tcp --source-address-prefixes '*' --direction Inbound \
            --destination-address-prefixes '*' --destination-port-ranges 22 -o none
        az network nsg rule create --nsg-name $nsg2_name -g $rg -n Allow_Inbound_HTTP --priority 1010 \
            --access Allow --protocol Tcp --source-address-prefixes '10.0.0.0/8' '172.16.0.0/12' '20.0.0.0/6' '192.168.0.0/16' \
            --destination-address-prefixes '*' --destination-port-ranges 9 80 443 -o none
        az network nsg rule create --nsg-name $nsg2_name -g $rg -n Allow_Inbound_IPsec --priority 1020 \
            --access Allow --protocol Udp --source-address-prefixes 'Internet' --direction Inbound \
            --destination-address-prefixes '*' --destination-port-ranges 500 4500 -o none
        az network nsg rule create --nsg-name $nsg2_name -g $rg -n Allow_Inbound_NTP --priority 1030 \
            --access Allow --protocol Udp --source-address-prefixes '10.0.0.0/8' '172.16.0.0/12' '20.0.0.0/6' '192.168.0.0/16' --direction Inbound \
            --destination-address-prefixes '*' --destination-port-ranges 123 -o none
        az network nsg rule create --nsg-name $nsg2_name -g $rg -n Allow_Inbound_Icmp --priority 1040 \
            --access Allow --protocol Icmp --source-address-prefixes '*' --direction Inbound \
            --destination-address-prefixes '*' --destination-port-ranges '*' -o none
        az network nsg rule create --nsg-name $nsg2_name -g $rg -n Allow_Outbound_All --priority 1000 \
            --access Allow --protocol '*' --source-address-prefixes '*' --direction Outbound \
            --destination-address-prefixes '*' --destination-port-ranges '*' -o none
    fi
    if [[ "$location1" != "$location2" ]]
    then
        storage_account2_name=vwan$RANDOM$location2
    else
        storage_account2_name=$storage_account1_name
    fi
    az storage account create -n $storage_account2_name -g $rg --sku Standard_LRS --kind StorageV2 -l $location2 -o none
    az network watcher flow-log create -l $location2 -n flowlog-$location2 -g $rg \
        --nsg $nsg2_name --storage-account $storage_account2_name --log-version 2 --retention 7 -o none
fi


# Create CSRs only if there are VPN Gateways

# Create CSR to simulate branch1
if [[ "$deploy_vpngw" == "yes" ]]
then
    # You might have to accept the CSR marketplace terms to deploy the image
    echo "Accepting the Cisco marketplace image for Cisco CSR..."
    az vm image terms accept -p $publisher -f $offer --plan $sku -o none
    echo "Creating NVAs..."
    az vm create -n branch1-nva -g $rg -l $location1 --image ${publisher}:${offer}:${sku}:${version} \
        --generate-ssh-keys --admin-username $username --nsg $nsg1_name --size $nva_size \
        --public-ip-address branch1-pip --public-ip-address-allocation static --private-ip-address $branch1_bgp_ip \
        --vnet-name branch1 --vnet-address-prefix $branch1_prefix --subnet nva --subnet-address-prefix $branch1_subnet -o none
    branch1_ip=$(az network public-ip show -n branch1-pip -g $rg --query ipAddress -o tsv)
    az network vpn-site create -n branch1 -g $rg -l $location1 --virtual-wan $vwan \
        --asn $branch1_asn --bgp-peering-address $branch1_bgp_ip --ip-address $branch1_ip --address-prefixes ${branch1_ip}/32 --device-vendor cisco --device-model csr --link-speed 100 -o none
    az network vpn-gateway connection create -n branch1 --gateway-name hubvpn1 -g $rg --remote-vpn-site branch1 \
        --enable-bgp true --protocol-type IKEv2 --shared-key "$password" --connection-bandwidth 100 --routing-weight 10 \
        --associated-route-table $hub1_default_rt_id --propagated-route-tables $hub1_default_rt_id --labels default --internet-security true -o none

    if [[ "$no_of_hubs" == "2" ]]
    then
        # Create CSR to simulate branch2
        az vm create -n branch2-nva -g $rg -l $location2 --image ${publisher}:${offer}:${sku}:${version} \
            --generate-ssh-keys --admin-username $username --nsg $nsg2_name --size $nva_size \
            --public-ip-address branch2-pip --public-ip-address-allocation static --private-ip-address $branch2_bgp_ip \
            --vnet-name branch2 --vnet-address-prefix $branch2_prefix --subnet nva --subnet-address-prefix $branch2_subnet -o none
        branch2_ip=$(az network public-ip show -n branch2-pip -g $rg --query ipAddress -o tsv)
        az network vpn-site create -n branch2 -g $rg -l $location2 --virtual-wan $vwan \
            --asn $branch2_asn --bgp-peering-address $branch2_bgp_ip --ip-address $branch2_ip --address-prefixes ${branch2_ip}/32 -o none
        az network vpn-gateway connection create -n branch2 --gateway-name hubvpn2 -g $rg --remote-vpn-site branch2 \
            --enable-bgp true --protocol-type IKEv2 --shared-key "$password" --connection-bandwidth 100 --routing-weight 10 \
            --associated-route-table $hub2_default_rt_id --propagated-route-tables $hub2_default_rt_id  --labels default --internet-security true -o none
    fi
fi

# Configure branches (CSRs)

# Get parameters for VPN GW in hub1
if [[ "$deploy_vpngw" == "yes" ]]
then
    vpngw1_config=$(az network vpn-gateway show -n hubvpn1 -g $rg)
    site=branch1
    vpngw1_gw0_pip=$(echo $vpngw1_config | jq -r '.bgpSettings.bgpPeeringAddresses[0].tunnelIpAddresses[0]')
    vpngw1_gw1_pip=$(echo $vpngw1_config | jq -r '.bgpSettings.bgpPeeringAddresses[1].tunnelIpAddresses[0]')
    vpngw1_gw0_bgp_ip=$(echo $vpngw1_config | jq -r '.bgpSettings.bgpPeeringAddresses[0].defaultBgpIpAddresses[0]')
    vpngw1_gw1_bgp_ip=$(echo $vpngw1_config | jq -r '.bgpSettings.bgpPeeringAddresses[1].defaultBgpIpAddresses[0]')
    vpngw1_bgp_asn=$(echo $vpngw1_config | jq -r '.bgpSettings.asn')  # This is today always 65515
    echo "Extracted info for hubvpn1: Gateway0 $vpngw1_gw0_pip, $vpngw1_gw0_bgp_ip. Gateway1 $vpngw1_gw1_pip, $vpngw1_gw0_bgp_ip. ASN $vpngw1_bgp_asn"

    if [[ "$no_of_hubs" == "2" ]]
    then
        # Get parameters for VPN GW in hub2
        vpngw2_config=$(az network vpn-gateway show -n hubvpn2 -g $rg)
        site=branch2
        vpngw2_gw0_pip=$(echo $vpngw2_config | jq -r '.bgpSettings.bgpPeeringAddresses[0].tunnelIpAddresses[0]')
        vpngw2_gw1_pip=$(echo $vpngw2_config | jq -r '.bgpSettings.bgpPeeringAddresses[1].tunnelIpAddresses[0]')
        vpngw2_gw0_bgp_ip=$(echo $vpngw2_config | jq -r '.bgpSettings.bgpPeeringAddresses[0].defaultBgpIpAddresses[0]')
        vpngw2_gw1_bgp_ip=$(echo $vpngw2_config | jq -r '.bgpSettings.bgpPeeringAddresses[1].defaultBgpIpAddresses[0]')
        vpngw2_bgp_asn=$(echo $vpngw2_config | jq -r '.bgpSettings.asn')  # This is today always 65515
        echo "Extracted info for hubvpn2: Gateway0 $vpngw2_gw0_pip, $vpngw2_gw0_bgp_ip. Gateway1 $vpngw2_gw1_pip, $vpngw2_gw0_bgp_ip. ASN $vpngw2_bgp_asn"
    fi

    # Wait until CSR in branch1 takes SSH connections
    wait_interval_csr=30
    echo "Waiting until CSR in branch${branch_id} is reachable..."
    command="sho ver | i uptime"
    command_output=$(ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch1_ip "$command")
    until [[ -n "$command_output" ]]
    do
        sleep $wait_interval_csr
        command_output=$(ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch1_ip "$command")
    done
    echo $command_output

    # Create CSR config for branch 1
    csr_config_url="https://raw.githubusercontent.com/erjosito/azure-wan-lab/master/csr_config_2tunnels_tokenized.txt"
    config_file_csr='branch1_csr.cfg'
    config_file_local='/tmp/branch1_csr.cfg'
    wget $csr_config_url -O $config_file_local
    sed -i "s|\*\*PSK\*\*|${password}|g" $config_file_local
    sed -i "s|\*\*GW0_Private_IP\*\*|${vpngw1_gw0_bgp_ip}|g" $config_file_local
    sed -i "s|\*\*GW1_Private_IP\*\*|${vpngw1_gw1_bgp_ip}|g" $config_file_local
    sed -i "s|\*\*GW0_Public_IP\*\*|${vpngw1_gw0_pip}|g" $config_file_local
    sed -i "s|\*\*GW1_Public_IP\*\*|${vpngw1_gw1_pip}|g" $config_file_local
    sed -i "s|\*\*BGP_ID\*\*|${branch1_asn}|g" $config_file_local
    ssh -o BatchMode=yes -o StrictHostKeyChecking=no $branch1_ip <<EOF
  config t
    file prompt quiet
EOF
    scp $config_file_local ${branch1_ip}:/${config_file_csr}
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch1_ip "copy bootflash:${config_file_csr} running-config"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch1_ip "wr mem"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch1_ip "sh ip int b"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch1_ip "sh ip bgp summary"
    myip=$(curl -s4 ifconfig.co)
    loopback_ip=10.11.11.11
    default_gateway=$branch1_gateway
    ssh -o BatchMode=yes -o StrictHostKeyChecking=no $branch1_ip <<EOF
config t
    username $username password 0 $password
    no ip domain lookup
    interface Loopback0
        ip address ${loopback_ip} 255.255.255.255
    router bgp ${branch1_asn}
        redistribute connected
        redistribute static route-map S2B
    route-map S2B
        match ip address prefix-list S2B
    ip prefix-list S2B permit ${branch1_prefix}
    ip route ${branch1_prefix_long} ${default_gateway}
    ip route ${vpngw1_gw0_pip} 255.255.255.255 ${default_gateway}
    ip route ${vpngw1_gw1_pip} 255.255.255.255 ${default_gateway}
    ip route ${myip} 255.255.255.255 ${default_gateway}
    line vty 0 15
        exec-timeout 0 0
end
write mem
EOF

    if [[ "$no_of_hubs" == "2" ]]
    then
        # Wait until CSR in branch2 takes SSH connections
        wait_interval_csr=30
        echo "Waiting until CSR in branch${branch_id} is reachable..."
        command="sho ver | i uptime"
        command_output=$(ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch2_ip "$command")
        until [[ -n "$command_output" ]]
        do
            sleep $wait_interval_csr
            command_output=$(ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch2_ip "$command")
        done
        echo $command_output

        # Create CSR config for branch 2
        csr_config_url="https://raw.githubusercontent.com/erjosito/azure-wan-lab/master/csr_config_2tunnels_tokenized.txt"
        config_file_csr='branch2_csr.cfg'
        config_file_local='/tmp/branch2_csr.cfg'
        wget $csr_config_url -O $config_file_local
        sed -i "s|\*\*PSK\*\*|${password}|g" $config_file_local
        sed -i "s|\*\*GW0_Private_IP\*\*|${vpngw2_gw0_bgp_ip}|g" $config_file_local
        sed -i "s|\*\*GW1_Private_IP\*\*|${vpngw2_gw1_bgp_ip}|g" $config_file_local
        sed -i "s|\*\*GW0_Public_IP\*\*|${vpngw2_gw0_pip}|g" $config_file_local
        sed -i "s|\*\*GW1_Public_IP\*\*|${vpngw2_gw1_pip}|g" $config_file_local
        sed -i "s|\*\*BGP_ID\*\*|${branch2_asn}|g" $config_file_local
        ssh -o BatchMode=yes -o StrictHostKeyChecking=no $branch2_ip <<EOF
  config t
    file prompt quiet
EOF
        scp $config_file_local ${branch2_ip}:/${config_file_csr}
        ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch2_ip "copy bootflash:${config_file_csr} running-config"
        ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch2_ip "wr mem"
        ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch2_ip "sh ip int b"
        ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $branch2_ip "sh ip bgp summary"
        myip=$(curl -s4 ifconfig.co)
        loopback_ip=10.22.22.22
        default_gateway=$branch2_gateway
        ssh -o BatchMode=yes -o StrictHostKeyChecking=no $branch2_ip <<EOF
config t
    username $username password 0 $password
    no ip domain lookup
    interface Loopback0
        ip address ${loopback_ip} 255.255.255.255
    router bgp ${branch2_asn}
        redistribute connected
        redistribute static route-map S2B
    route-map S2B
        match ip address prefix-list S2B
    ip prefix-list S2B permit ${branch2_prefix}
    ip route ${branch2_prefix_long} ${default_gateway}
    ip route ${vpngw2_gw0_pip} 255.255.255.255 ${default_gateway}
    ip route ${vpngw2_gw1_pip} 255.255.255.255 ${default_gateway}
    ip route ${myip} 255.255.255.255 ${default_gateway}
    line vty 0 15
        exec-timeout 0 0
end
wr mem
EOF
    fi   # If $no_of_hubs == 2
fi  # if $deploy_vpngw == yes

# Configure VPN gateways to log to Azure Monitor
# Create LA workspace if it doesnt exist
logws_name=$(az monitor log-analytics workspace list -g $rg --query '[0].name' -o tsv)
if [[ -z "$logws_name" ]]
then
    logws_name=vwanlogs$RANDOM
    echo "Creating log analytics workspace $logws_name..."
    az monitor log-analytics workspace create -n $logws_name -g $rg -l $location1 -o none
fi
logws_id=$(az resource list -g $rg -n $logws_name --query '[].id' -o tsv)
logws_customerid=$(az monitor log-analytics workspace show -n $logws_name -g $rg --query customerId -o tsv)
if [[ "$deploy_vpngw" == "yes" ]]
then
    # VPN gateways
    echo "Configuring VPN gateways..."
    gw_id_list=$(az network vpn-gateway list -g $rg --query '[].id' -o tsv)
    while IFS= read -r gw_id; do
        az monitor diagnostic-settings create -n mydiag --resource $gw_id --workspace $logws_id \
            --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
            --logs '[{"category": "GatewayDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
                    {"category": "TunnelDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}},
                    {"category": "RouteDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}},
                    {"category": "IKEDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]' -o none
    done <<< "$gw_id_list"
fi

if [[ "$secure_hub" == "yes" ]]
then
    # Create Azure Firewall policy with sample policies
    azfw_policy_name=vwanfwpolicy
    az network firewall policy create -n $azfw_policy_name -g $rg
    az network firewall policy rule-collection-group create -n ruleset01 --policy-name $azfw_policy_name -g $rg --priority 100
    # Allow SSH and HTTP for connection monitor (uses TCP9 too)
    echo "Creating rule to allow SSH and HTTP..."
    az network firewall policy rule-collection-group collection add-filter-collection --policy-name $azfw_policy_name --rule-collection-group-name ruleset01 -g $rg \
        --name mgmt --collection-priority 101 --action Allow --rule-name allowSSHnHTTP --rule-type NetworkRule --description "TCP 22" \
        --destination-addresses 10.0.0.0/8 172.16.0.0/12 20.0.0.0/6 --source-addresses 10.0.0.0/8 172.16.0.0/12 20.0.0.0/6 --ip-protocols TCP --destination-ports 9 22 80 -o none
    # Allow ICMP
    # echo "Creating rule to allow ICMP..."
    # az network firewall policy rule-collection-group collection add-filter-collection --policy-name $azfw_policy_name --rule-collection-group-name ruleset01 -g $rg \
    #     --name icmp --collection-priority 102 --action Allow --rule-name allowICMP --rule-type NetworkRule --description "ICMP traffic" \
    #     --destination-addresses 10.0.0.0/8 172.16.0.0/12 20.0.0.0/6 --source-addresses 10.0.0.0/8 172.16.0.0/12 20.0.0.0/6 --ip-protocols ICMP --destination-ports "1-65535" >/dev/null
    # Allow NTP
    echo "Creating rule to allow NTP..."
    az network firewall policy rule-collection-group collection add-filter-collection --policy-name $azfw_policy_name --rule-collection-group-name ruleset01 -g $rg \
        --name ntp --collection-priority 103 --action Allow --rule-name allowNTP --rule-type NetworkRule --description "Egress NTP traffic" \
        --destination-addresses '*' --source-addresses "10.0.0.0/8" "20.0.0.0/6" --ip-protocols UDP --destination-ports "123" -o none
    # Example application collection with 2 rules (ipconfig.co, api.ipify.org)
    echo "Creating rule to allow ifconfig.co and api.ipify.org..."
    az network firewall policy rule-collection-group collection add-filter-collection --policy-name $azfw_policy_name --rule-collection-group-name ruleset01 -g $rg \
        --name ifconfig --collection-priority 201 --action Allow --rule-name allowIfconfig --rule-type ApplicationRule --description "ifconfig" \
        --target-fqdns "ifconfig.co" --source-addresses "10.0.0.0/8" "172.16.0.0/12" "20.0.0.0/6" --protocols Http=80 Https=443 -o none
    az network firewall policy rule-collection-group collection rule add -g $rg --policy-name $azfw_policy_name --rule-collection-group-name ruleset01 --collection-name ifconfig \
        --name ipify --target-fqdns "api.ipify.org" --source-addresses "10.0.0.0/8" "172.16.0.0/12" "20.0.0.0/6" --protocols Http=80 Https=443 --rule-type ApplicationRule -o none
    # Example application collection with wildcards (*.ubuntu.com)
    echo "Creating rule to allow *.ubuntu.com..."
    az network firewall policy rule-collection-group collection add-filter-collection --policy-name $azfw_policy_name --rule-collection-group-name ruleset01 -g $rg \
        --name ubuntu --collection-priority 202 --action Allow --rule-name repos --rule-type ApplicationRule --description "ubuntucom" \
        --target-fqdns 'ubuntu.com' '*.ubuntu.com' --source-addresses '*' --protocols Http=80 Https=443 -o none
    # Mgmt traffic to Azure
    az network firewall policy rule-collection-group collection add-filter-collection --policy-name $azfw_policy_name --rule-collection-group-name ruleset01 -g $rg \
        --name azure --collection-priority 203 --action Allow --rule-name azmonitor --rule-type ApplicationRule --description "Azure Monitor" \
        --target-fqdns '*.opinsights.azure.com' '*.azure-automation.net' --source-addresses '*' --protocols Https=443 -o none

    # Create Azure Firewalls in the virtual hubs and configure static routes to firewall in the VWAN hub route tables
    echo "Creating Azure Firewall in hub1..."
    az network firewall create -n azfw1 -g $rg --vhub hub1 --policy $azfw_policy_name -l $location1 --sku AZFW_Hub --public-ip-count 1 -o none
    azfw1_id=$(az network firewall show -n azfw1 -g $rg --query id -o tsv)
    az network vhub route-table route add -n defaultRouteTable --vhub-name hub1 -g $rg \
        --route-name default --destination-type CIDR --destinations "0.0.0.0/0" "10.0.0.0/8" \
        --next-hop-type ResourceId --next-hop $azfw1_id -o none
    az network vhub route-table route add -n hub1Vnet --vhub-name hub1 -g $rg \
        --route-name default --destination-type CIDR --destinations "0.0.0.0/0" "10.0.0.0/8" "172.16.0.0/12" \
        --next-hop-type ResourceId --next-hop $azfw1_id -o none
    if [[ "$no_of_hubs" == "2" ]]
    then
        echo "Creating Azure Firewall in hub2..."
        az network firewall create -n azfw2 -g $rg --vhub hub2 --policy $azfw_policy_name -l $location2 --sku AZFW_Hub --public-ip-count 1 -o none
        azfw2_id=$(az network firewall show -n azfw2 -g $rg --query id -o tsv)
        az network vhub route-table route add -n defaultRouteTable --vhub-name hub2 -g $rg \
            --route-name default --destination-type CIDR --destinations "0.0.0.0/0" "10.0.0.0/8" \
            --next-hop-type ResourceId --next-hop $azfw2_id -o none
        az network vhub route-table route add -n hub2Vnet --vhub-name hub2 -g $rg \
            --route-name default --destination-type CIDR --destinations "0.0.0.0/0" "10.0.0.0/8" "172.16.0.0/12" \
            --next-hop-type ResourceId --next-hop $azfw2_id -o none
    fi


    # Azure Firewalls
    echo "Configuring Azure Firewalls..."
    fw_id_list=$(az network firewall list -g $rg --query '[].id' -o tsv)
    while IFS= read -r fw_id; do
        az monitor diagnostic-settings create -n mydiag --resource $fw_id --workspace $logws_id \
            --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
            --logs '[{"category": "AzureFirewallApplicationRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
                    {"category": "AzureFirewallNetworkRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]' -o none
    done <<< "$fw_id_list"
fi

# Create cloudinit file
# - Installing apache to use to verify TCP on port 80
# - Enabling OS IP fwding everywhere, even if it is not really needed
cloudinit_file=/tmp/cloudinit.txt
cat <<EOF > $cloudinit_file
#cloud-config
package_upgrade: true
packages:
  - apache2
runcmd:
  - sysctl -w net.ipv4.ip_forward=1
EOF

# Create spokes
for spoke in $(seq 1 ${no_of_spokes})
do
    create_spoke 1 $spoke
done
if [[ "$no_of_hubs" == "2" ]]
then
    for spoke in $(seq 1 ${no_of_spokes})
    do
        create_spoke 2 $spoke
    done
fi

# Backdoor for access from the testing device over the Internet
myip=$(curl -s4 ifconfig.co)
echo "Creating RT for spokes in $location1..."
az network route-table create -n spokes-$location1 -g $rg -l $location1 -o none
az network route-table route create -n mypc -g $rg --route-table-name spokes-$location1 --address-prefix "${myip}/32" --next-hop-type Internet -o none
for spoke in $(seq 1 ${no_of_spokes})
do
    echo "Associating VNet spoke1${spoke}-${location1} to RT spokes-$location1..."
    az network vnet subnet update -n vm --vnet-name spoke1${spoke}-${location1} -g $rg --route-table spokes-$location1 -o none
done
if [[ "$no_of_hubs" == "2" ]]
then
    if [[ "$location1" != "$location2" ]]
    then
    echo "Creating RT for spokes in $location2..."
        az network route-table create -n spokes-$location2 -g $rg -l $location2 -o none
        az network route-table route create -n mypc -g $rg --route-table-name spokes-$location2 --address-prefix "${myip}/32" --next-hop-type Internet -o none
    fi
    for spoke in $(seq 1 ${no_of_spokes})
    do
        echo "Associating VNet spoke2${spoke}-${location1} to RT spokes-$location2..."
        az network vnet subnet update -n vm --vnet-name spoke2${spoke}-${location2} -g $rg --route-table spokes-$location2 -o none
    done
fi

# Optional: additional spokes with NVA and 2 indirect spokes attached to them
if [[ "$indirect_spokes" == "yes" ]]
then
    indirect_spoke_id=$((no_of_spokes+1))
    # Create VMs and VNets
    echo "Creating NVA spoke 1${indirect_spoke_id} and indirect spokes 1${indirect_spoke_id}1 and 1${indirect_spoke_id}2..."
    create_spoke 1 ${indirect_spoke_id}
    create_spoke 1 ${indirect_spoke_id}1 no
    create_spoke 1 ${indirect_spoke_id}2 no
    if [[ "$no_of_hubs" == "2" ]]
    then
        echo "Creating NVA spoke 2${indirect_spoke_id} and indirect spokes 2${indirect_spoke_id}1 and 2${indirect_spoke_id}2..."
        create_spoke 2 ${indirect_spoke_id}
        create_spoke 2 ${indirect_spoke_id}1 no
        create_spoke 2 ${indirect_spoke_id}2 no
    fi

    # Indirect spoke peerings
    echo "Creating VNet peerings to indirect spokes..."
    az network vnet peering create -n 1${indirect_spoke_id}1to1${indirect_spoke_id} -g $rg --vnet-name spoke1${indirect_spoke_id}1-${location1} --remote-vnet spoke1${indirect_spoke_id}-${location1} --allow-vnet-access --allow-forwarded-traffic -o none
    az network vnet peering create -n 1${indirect_spoke_id}2to1${indirect_spoke_id} -g $rg --vnet-name spoke1${indirect_spoke_id}2-${location1} --remote-vnet spoke1${indirect_spoke_id}-${location1} --allow-vnet-access --allow-forwarded-traffic -o none
    az network vnet peering create -n 14to1${indirect_spoke_id}1 -g $rg --vnet-name spoke1${indirect_spoke_id}-${location1} --remote-vnet spoke1${indirect_spoke_id}1-${location1} --allow-vnet-access --allow-forwarded-traffic -o none
    az network vnet peering create -n 14to1${indirect_spoke_id}2 -g $rg --vnet-name spoke1${indirect_spoke_id}-${location1} --remote-vnet spoke1${indirect_spoke_id}2-${location1} --allow-vnet-access --allow-forwarded-traffic -o none
    if [[ "$no_of_hubs" == "2" ]]
    then
        az network vnet peering create -n 2${indirect_spoke_id}1to2${indirect_spoke_id} -g $rg --vnet-name spoke2${indirect_spoke_id}1-${location2} --remote-vnet spoke2${indirect_spoke_id}-${location2} --allow-vnet-access --allow-forwarded-traffic -o none
        az network vnet peering create -n 2${indirect_spoke_id}2to2${indirect_spoke_id} -g $rg --vnet-name spoke2${indirect_spoke_id}2-${location2} --remote-vnet spoke2${indirect_spoke_id}-${location2} --allow-vnet-access --allow-forwarded-traffic -o none
        az network vnet peering create -n 24to2${indirect_spoke_id}1 -g $rg --vnet-name spoke2${indirect_spoke_id}-${location2} --remote-vnet spoke2${indirect_spoke_id}1-${location2} --allow-vnet-access --allow-forwarded-traffic -o none
        az network vnet peering create -n 24to2${indirect_spoke_id}2 -g $rg --vnet-name spoke2${indirect_spoke_id}-${location2} --remote-vnet spoke2${indirect_spoke_id}2-${location2} --allow-vnet-access --allow-forwarded-traffic -o none
    fi
    # Configure IP forwarding in the NVA NICs
    echo "Configuring IP forwarding in NVA NICs..."
    vm_names=("spoke${indirect_spoke_id}4-vm" "spoke2${indirect_spoke_id}-vm")
    for vm_name in ${vm_names[@]}; do
        echo "Enabling IP forwarding for $vm_name..."
        vm_nic_id=$(az vm show -n $vm_name -g $rg --query 'networkProfile.networkInterfaces[0].id' -o tsv)
        az network nic update --ids $vm_nic_id --ip-forwarding -o none
    done
    # RT for indirect spokes 1${indirect_spoke_id}1/1${indirect_spoke_id}2
    echo "Creating route tables for indirect spokes with default route pointing to the NVA..."
    myip=$(curl -s4 ifconfig.co)
    nva1_nic_id=$(az vm show -n spoke1${indirect_spoke_id}-vm -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
    nva1_ip=$(az network nic show --ids $nva1_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv)
    az network route-table create -n indirectspokes-$location1 -g $rg -l $location1 -o none
    az network route-table route create -n default -g $rg --route-table-name indirectspokes-$location1 \
        --address-prefix "0.0.0.0/0" --next-hop-type VirtualAppliance --next-hop-ip-address $nva1_ip -o none
    az network route-table route create -n mypc -g $rg --route-table-name indirectspokes-$location1 \
        --address-prefix "${myip}/32" --next-hop-type Internet -o none
    az network vnet subnet update -n vm --vnet-name spoke1${indirect_spoke_id}1-${location1} -g $rg --route-table indirectspokes-$location1 -o none
    az network vnet subnet update -n vm --vnet-name spoke1${indirect_spoke_id}2-${location1} -g $rg --route-table indirectspokes-$location1 -o none
    if [[ "$no_of_hubs" == "2" ]]
    then
        nva2_nic_id=$(az vm show -n spoke2${indirect_spoke_id}-vm -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
        nva2_ip=$(az network nic show --ids $nva2_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv)
        az network route-table create -n indirectspokes-$location2 -g $rg -l $location2 -o none
        az network route-table route create -n default -g $rg --route-table-name indirectspokes-$location2 \
            --address-prefix "0.0.0.0/0" --next-hop-type VirtualAppliance --next-hop-ip-address $nva2_ip -o none
        az network route-table route create -n mypc -g $rg --route-table-name indirectspokes-$location2 \
            --address-prefix "${myip}/32" --next-hop-type Internet -o none
        az network vnet subnet update -n vm --vnet-name spoke2${indirect_spoke_id}1-${location2} -g $rg --route-table indirectspokes-$location2 -o none
        az network vnet subnet update -n vm --vnet-name spoke2${indirect_spoke_id}2-${location2} -g $rg --route-table indirectspokes-$location2 -o none
    fi
    # RT with backdoor for nva spokes and default to Internet
    echo "Creating route tables for the NVAs and adding default routing to the Internet..."
    az network route-table create -n nva1${indirect_spoke_id}-$location1 -g $rg -l $location1 -o none
    az network route-table route create -n default -g $rg --route-table-name nva1${indirect_spoke_id}-$location1 \
        --address-prefix "0.0.0.0/0" --next-hop-type Internet -o none
    az network vnet subnet update -n vm --vnet-name spoke1${indirect_spoke_id}-$location1 -g $rg --route-table nva1${indirect_spoke_id}-$location1 -o none
    if [[ "$no_of_hubs" == "2" ]]
    then
        az network route-table create -n nva2${indirect_spoke_id}-$location2 -g $rg -l $location2 -o none
        az network route-table route create -n default -g $rg --route-table-name nva2${indirect_spoke_id}-$location2 \
            --address-prefix "0.0.0.0/0" --next-hop-type Internet -o none
        az network vnet subnet update -n vm --vnet-name spoke2${indirect_spoke_id}-$location2 -g $rg --route-table nva2${indirect_spoke_id}-$location2 -o none
    fi
    # Install BIRD in the NVAs
    echo "Installing BIRD in NVAs..."
    if [[ "$no_of_hubs" == "1" ]]
    then
        vm_names=( "spoke1${indirect_spoke_id}-vm" )
    else
        vm_names=("spoke1${indirect_spoke_id}-vm" "spoke2${indirect_spoke_id}-vm")
    fi
    for vm_name in ${vm_names[@]}; do
        echo "Installing BIRD in VM $vm_name..."
        nic_id=$(az vm show -n $vm_name -g $rg --query 'networkProfile.networkInterfaces[0].id' -o tsv)
        pip_id=$(az network nic show --ids $nic_id --query 'ipConfigurations[0].publicIpAddress.id' -o tsv)
        vm_pip=$(az network public-ip show --ids $pip_id --query 'ipAddress' -o tsv)
        ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $vm_pip "sudo apt update && sudo apt install -y bird"
    done
fi

# VMs in VPN branches
if [[ "$deploy_vpngw" == "yes" ]]
then
    # VM in branch1
    az vm create -n branch1-vm -g $rg -l $location1 --image ubuntuLTS --admin-username $username --generate-ssh-keys \
        --public-ip-address branch1-vm-pip --vnet-name branch1 --nsg $nsg1_name --size $vm_size \
        --subnet vm --subnet-address-prefix $branch1_vm_subnet --custom-data $cloudinit_file
    az vm extension set --vm-name branch1-vm -g $rg -n NetworkWatcherAgentLinux --publisher Microsoft.Azure.NetworkWatcher --version 1.4
    az network route-table create -n branch1vm-$location1 -g $rg -l $location1
    myip=$(curl -s4 ifconfig.co)
    az network route-table route create -n mypc -g $rg --route-table-name branch1vm-$location1 \
        --address-prefix "${myip}/32" --next-hop-type Internet
    az network route-table route create -n default -g $rg --route-table-name branch1vm-$location1 \
        --address-prefix "0.0.0.0/0" --next-hop-type VirtualAppliance --next-hop-ip-address $branch1_bgp_ip
    az network vnet subnet update -n vm --vnet-name branch1 -g $rg --route-table branch1vm-$location1
    # VM in branch2
    if [[ "$no_of_hubs" == "2" ]]
    then
        az vm create -n branch2-vm -g $rg -l $location2 --image ubuntuLTS --admin-username $username --generate-ssh-keys \
            --public-ip-address branch2-vm-pip --vnet-name branch2 --nsg $nsg2_name --size $vm_size \
            --subnet vm --subnet-address-prefix $branch2_vm_subnet --custom-data $cloudinit_file
        az vm extension set --vm-name branch2-vm -g $rg -n NetworkWatcherAgentLinux --publisher Microsoft.Azure.NetworkWatcher --version 1.4
        az network route-table create -n branch2vm-$location2 -g $rg -l $location2
        az network route-table route create -n mypc -g $rg --route-table-name branch2vm-$location2 \
            --address-prefix "${myip}/32" --next-hop-type Internet
        az network route-table route create -n default -g $rg --route-table-name branch2vm-$location2 \
            --address-prefix "0.0.0.0/0" --next-hop-type VirtualAppliance --next-hop-ip-address $branch2_bgp_ip
        az network vnet subnet update -n vm --vnet-name branch2 -g $rg --route-table branch2vm-$location2
    fi
    # Configure IP forwarding in the CSR NICs
    if [[ "$no_of_hubs" == "2" ]]
    then
        vm_names=("branch1-nva")
    else
        vm_names=("branch1-nva" "branch2-nva")
    fi
    for vm_name in ${vm_names[@]}; do
        echo "Enabling IP forwarding for $vm_name..."
        vm_nic_id=$(az vm show -n $vm_name -g $rg --query 'networkProfile.networkInterfaces[0].id' -o tsv)
        az network nic update --ids $vm_nic_id --ip-forwarding
    done
fi

# Optional: configure BGP in the NVAs in NVA spokes to VWAN
if [[ "$nva_bgp" == "yes" ]]
then
    # Variables
    echo "Getting information about NVA in spoke 1${indirect_spoke_id}..."
    username=$(whoami)
    nva1_nic_id=$(az vm show -n "spoke1${indirect_spoke_id}-vm" -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
    nva1_ip=$(az network nic show --ids $nva1_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv) && echo "$nva1_ip"
    nva1_pip=$(az network public-ip show -n "spoke1${indirect_spoke_id}-pip" -g $rg --query ipAddress -o tsv) && echo "$nva1_pip"
    nva1_default_gw="10.1.${indirect_spoke_id}.1"
    nva1_asn="6501${indirect_spoke_id}"
    echo "Getting information about the Route Service in hub1..."
    hub1_rs_ip1=$(az network vhub show -n hub1 -g $rg --query 'virtualRouterIps[0]' -o tsv) && echo $hub1_rs_ip1
    hub1_rs_ip2=$(az network vhub show -n hub1 -g $rg --query 'virtualRouterIps[1]' -o tsv) && echo $hub1_rs_ip2
    hub1_rs_asn=$(az network vhub show -n hub1 -g $rg --query 'virtualRouterAsn' -o tsv) && echo $hub1_rs_asn
    echo "Configuring static route in NVA1 for the hub address space $vwan_hub1_prefix"
    ssh -n -o StrictHostKeyChecking=no -o BatchMode=yes "$nva1_pip" "sudo ip route add $vwan_hub1_prefix via $nva1_default_gw"
    if [[ "$nva_in_hub2" == "yes" ]] && [[ "$no_of_hubs" == "2" ]]
    then
        echo "Getting information about NVA in spoke 2${indirect_spoke_id}..."
        nva2_nic_id=$(az vm show -n "spoke2${indirect_spoke_id}-vm" -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
        nva2_ip=$(az network nic show --ids $nva2_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv) && echo "$nva2_ip"
        nva2_pip=$(az network public-ip show -n "spoke2${indirect_spoke_id}-pip" -g $rg --query ipAddress -o tsv) && echo "$nva2_pip"
        nva2_default_gw="10.2.${indirect_spoke_id}.1"
        nva2_asn="6502${indirect_spoke_id}"
        echo "Getting information about the Route Service in hub2..."
        hub2_rs_ip1=$(az network vhub show -n hub2 -g $rg --query 'virtualRouterIps[0]' -o tsv) && echo $hub2_rs_ip1
        hub2_rs_ip2=$(az network vhub show -n hub2 -g $rg --query 'virtualRouterIps[1]' -o tsv) && echo $hub2_rs_ip2
        hub2_rs_asn=$(az network vhub show -n hub2 -g $rg --query 'virtualRouterAsn' -o tsv) && echo $hub2_rs_asn
        echo "Configuring static route in NVA2 for the hub address space $vwan_hub2_prefix"
        ssh -n -o StrictHostKeyChecking=no -o BatchMode=yes "$nva2_pip" "sudo ip route add $vwan_hub2_prefix via $nva2_default_gw"
    fi
    # spoke14-vm config
    bird_config_file="/tmp/bird1${indirect_spoke_id}.conf"
    cat <<EOF > $bird_config_file
log syslog all;
router id $nva1_ip;
protocol device {
        scan time 10;
}
protocol direct {
    disabled;
}
protocol kernel {
    preference 254;
    learn;
    merge paths on;
    export all;
    import all;
    #export none;
    #disabled;
}
protocol static {
    route 1${indirect_spoke_id}.1${indirect_spoke_id}.1${indirect_spoke_id}.1${indirect_spoke_id}/32 via $nva1_default_gw;   # Test route
    route 10.1.${indirect_spoke_id}1.0/24 via $nva1_default_gw; # Route to spoke1${spoke}1
    route 10.1.${indirect_spoke_id}2.0/24 via $nva1_default_gw; # Route to spoke1${spoke}2
}
protocol bgp rs0 {
    description "VWAN Route Service instance 0";
    multihop;
    local $nva1_ip as $nva1_asn;
    neighbor $hub1_rs_ip1 as $hub1_rs_asn;
        import filter {accept;};
        export filter {accept;};
}
protocol bgp rs1 {
    description "VWAN Route Service instance 1";
    multihop;
    local $nva1_ip as $nva1_asn;
    neighbor $hub1_rs_ip2 as $hub1_rs_asn;
        import filter {accept;};
        export filter {accept;};
}
EOF
    echo "Copying BIRD config file to NVA in spoke 1${indirect_spoke_id}..."
    scp $bird_config_file "${nva1_pip}:/home/${username}/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo mv /home/${username}/bird.conf /etc/bird/bird.conf"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo systemctl restart bird"

    if [[ "$no_of_hubs" == "2" ]]
    then
        # NVA in spoke24-vm config
        bird_config_file=/tmp/bird2${indirect_spoke_id}.conf
        cat <<EOF > $bird_config_file
log syslog all;
router id $nva2_ip;
protocol device {
        scan time 10;
}
protocol direct {
    disabled;
}
protocol kernel {
    preference 254;
    learn;
    merge paths on;
    export all;
    import all;
    #export none;
    #disabled;
}
protocol static {
    route 2${indirect_spoke_id}.2${indirect_spoke_id}.2${indirect_spoke_id}.2${indirect_spoke_id}/32 via $nva2_default_gw;   # Test route
    route 10.2.${indirect_spoke_id}1.0/24 via $nva2_default_gw; # Route to spoke2${spoke}1
    route 10.2.${indirect_spoke_id}2.0/24 via $nva2_default_gw; # Route to spoke2${spoke}2
}
protocol bgp rs0 {
    description "VWAN Route Service instance 0";
    multihop;
    local $nva2_ip as $nva2_asn;
    neighbor $hub2_rs_ip1 as $hub2_rs_asn;
        import filter {accept;};
        export filter {accept;};
}
protocol bgp rs1 {
    description "VWAN Route Service instance 1";
    multihop;
    local $nva2_ip as $nva2_asn;
    neighbor $hub2_rs_ip2 as $hub2_rs_asn;
        import filter {accept;};
        export filter {accept;};
}
EOF
        echo "Copying BIRD config file to NVA in spoke 2${indirect_spoke_id}..."
        scp $bird_config_file "${nva2_pip}:/home/${username}/bird.conf"
        ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo mv /home/${username}/bird.conf /etc/bird/bird.conf"
        ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo systemctl restart bird"
    fi
    # Now configure the VWAN side
    nva1_cx_id=$( az network vhub connection show -n "spoke1${indirect_spoke_id}" --vhub-name hub1 -g $rg -o tsv --query id)
    echo "Creating BGP peering to hub1..."
    az network vhub bgpconnection create -n spoke1${indirect_spoke_id} -g $rg --vhub-name hub1 --peer-asn "$nva1_asn" --peer-ip "$nva1_ip" --vhub-conn "$nva1_cx_id" -o none
    if [[ "$no_of_hubs" == "2" ]]
    then
        nva2_cx_id=$( az network vhub connection show -n spoke2${indirect_spoke_id} --vhub-name hub2 -g $rg -o tsv --query id)
        echo "Creating BGP peering to hub2..."
        az network vhub bgpconnection create -n spoke2${indirect_spoke_id} -g $rg --vhub-name hub2 --peer-asn "$nva2_asn" --peer-ip "$nva2_ip" --vhub-conn "$nva2_cx_id" -o none
    fi
    # Wait
    echo "Waiting 30 seconds for BGP to come up..."
    sleep 30
    # Diagnostics for NVA in hub1
    echo "Performing some checks on NVA in spoke1${indirect_spoke_id}..."
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo birdc show protocols"
    # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo birdc show route protocol rs0"
    # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo birdc show route export rs0"
    az network nic show-effective-route-table --ids $nva1_nic_id -o table
    # Diagnostics for NVA in hub2
    if [[ "$nva_in_hub2" == "yes" ]] && [[ "$no_of_hubs" == "2" ]]
    then
        echo "Performing some checks on NVA in spoke2${indirect_spoke_id}..."
        ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo birdc show protocols"
        # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo birdc show route protocol rs0"
        # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo birdc show route export rs0"
        az network nic show-effective-route-table --ids $nva2_nic_id -o table
    fi
fi

# Optional: enable/disable SNAT in the NVAs
if [[ "$indirect_spokes" == "yes" ]]
then
    nva1_pip=$(az network public-ip show -n "spoke1${indirect_spoke_id}-pip" -g $rg --query ipAddress -o tsv)
    # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo iptables -t nat -A POSTROUTING ! -d '10.0.0.0/8' -o eth0 -j MASQUERADE"
    # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo iptables -t nat -D POSTROUTING ! -d '10.0.0.0/8' -o eth0 -j MASQUERADE"
    # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE"
    # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE"
    echo "Current NAT configuration in NVA in spoke 1${indirect_spoke_id}:"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo iptables -L -t nat"
    # Optional: enable/disable a rule to drop ICMP traffic in the NVA
    # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo iptables -A INPUT -p ICMP --icmp-type 8 -j DROP"
    # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo iptables -A FORWARD -p ICMP --icmp-type 8 -j DROP"
    # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo iptables -D INPUT -p ICMP --icmp-type 8 -j DROP"
    # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo iptables -D FORWARD -p ICMP --icmp-type 8 -j DROP"
    echo "Current iptables rules in NVA in spoke 1${indirect_spoke_id}:"
    ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva1_pip "sudo iptables -L"
    if [[ "$no_of_hubs" == "2" ]]
    then
        nva2_pip=$(az network public-ip show -n "spoke2${indirect_spoke_id}-pip" -g $rg --query ipAddress -o tsv)
        # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo iptables -t nat -A POSTROUTING ! -d '10.0.0.0/8' -o eth0 -j MASQUERADE"
        # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo iptables -t nat -D POSTROUTING ! -d '10.0.0.0/8' -o eth0 -j MASQUERADE"
        # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE"
        # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE"
        echo "Current NAT configuration in NVA in spoke 2${indirect_spoke_id}:"
        ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo iptables -L -t nat"
        # Optional: enable/disable a rule to drop ICMP traffic in the NVA
        # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo iptables -A INPUT -p ICMP --icmp-type 8 -j DROP"
        # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo iptables -A FORWARD -p ICMP --icmp-type 8 -j DROP"
        # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo iptables -D INPUT -p ICMP --icmp-type 8 -j DROP"
        # ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo iptables -D FORWARD -p ICMP --icmp-type 8 -j DROP"
        echo "Current iptables rules in NVA in spoke 2${indirect_spoke_id}:"
        ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $nva2_pip "sudo iptables -L"
    fi
fi

# Optional: add some VMs with public IPs
# This can be used to test AzFW default SNAT behavior
if [[ "$public_ip" == "yes" ]]
then
    # Add public subnet to branch1
    new_subnet=21.21.21.0/24
    new_subnet_long="21.21.21.0 255.255.255.0"
    new_subnet_name=public
    vm_name=branch1-vm2
    az network vnet update -n branch1 -g $rg --address-prefixes $branch1_prefix $new_subnet
    az vm create -n $vm_name -g $rg -l $location1 --image ubuntuLTS --admin-username $username --generate-ssh-keys \
        --public-ip-address ${vm_name}-pip --vnet-name branch1 --nsg $nsg1_name --size $vm_size \
        --subnet $new_subnet_name --subnet-address-prefix $new_subnet --custom-data $cloudinit_file
    az vm extension set --vm-name $vm_name -g $rg -n NetworkWatcherAgentLinux --publisher Microsoft.Azure.NetworkWatcher --version 1.4
    az network vnet subnet update -n $new_subnet_name --vnet-name branch1 -g $rg --route-table branch1vm-$location1
    default_gateway=$branch1_gateway
    branch1_ip=$(az network public-ip show -n branch1-pip -g $rg --query ipAddress -o tsv)
    ssh -o BatchMode=yes -o StrictHostKeyChecking=no $branch1_ip <<EOF
config t
    ip prefix-list S2B permit ${new_subnet}
    ip route ${new_subnet_long} ${default_gateway}
end
wr mem
EOF

    # Add public subnet to branch2
    new_subnet=22.22.22.0/24
    new_subnet_long="22.22.22.0 255.255.255.0"
    new_subnet_name=public
    vm_name=branch2-vm2
    az network vnet update -n branch2 -g $rg --address-prefixes $branch2_prefix $new_subnet
    az vm create -n $vm_name -g $rg -l $location2 --image ubuntuLTS --admin-username $username --generate-ssh-keys \
        --public-ip-address ${vm_name}-pip --vnet-name branch2 --nsg $nsg2_name --size $vm_size \
        --subnet $new_subnet_name --subnet-address-prefix $new_subnet --custom-data $cloudinit_file
    az vm extension set --vm-name $vm_name -g $rg -n NetworkWatcherAgentLinux --publisher Microsoft.Azure.NetworkWatcher --version 1.4
    az network vnet subnet update -n $new_subnet_name --vnet-name branch2 -g $rg --route-table branch2vm-$location2
    default_gateway=$branch2_gateway
    branch2_ip=$(az network public-ip show -n branch2-pip -g $rg --query ipAddress -o tsv)
    ssh -o BatchMode=yes -o StrictHostKeyChecking=no $branch2_ip <<EOF
config t
    ip prefix-list S2B permit ${new_subnet}
    ip route ${new_subnet_long} ${default_gateway}
end
wr mem
EOF
fi

# Optional: deploy NVA in the hubs
if [[ "$deploy_nva_hub1" == "yes" ]]
then
    create_hub_nva 1
    #configure_hub_nva_bgp 1    # If no branches (only configures BGP to RS)
    create_hub_nva_branch 1     # Takes care as well of the BGP config to the RS
fi
if [[ "$deploy_nva_hub2" == "yes" ]] && [[ "$no_of_hubs" == "2" ]]
then
    create_hub_nva 2
    #configure_hub_nva_bgp 2    # If no branches (only configures BGP to RS)
    create_hub_nva_branch 2     # Takes care as well of the BGP config to the RS
fi

# Optional: ExpressRoute (WORK IN PROGRESS!!)
if [[ "$deploy_er" == "yes" ]]
then
    # Create onprem ER branch
    onprem_vnet_name=branch5
    echo "Creating VNet branch5 to simulate an ER branch..."
    az network vnet create -n $onprem_vnet_name -g $rg --address-prefix $branch5_prefix -o none
    az network vnet subnet create -g $rg -n $branch5_vm_subnet_name --vnet-name $onprem_vnet_name --address-prefix $branch5_vm_subnet_prefix -o none
    az network vnet subnet create -g $rg -n GatewaySubnet --vnet-name $onprem_vnet_name --address-prefix $branch5_gw_subnet_prefix -o none
    echo "Creating ER gateway in branch5 (--no-wait)..."
    az network public-ip create -g $rg -n ${branch5_gw_name}-pip --allocation-method Dynamic --sku Basic -o none
    az network vnet-gateway create -g $rg -n ${branch5_gw_name} --gateway-type ExpressRoute --sku Standard -l $branch5_location --vnet $onprem_vnet_name --public-ip-addresses "${branch5_gw_name}-pip" --no-wait -o none
    # Create VWAN ER and circuits
    echo "Creating ER gateway in hub1..."
    az network express-route gateway create -g $rg -n hub1ergw --virtual-hub hub1 -l $location1 -o none
    echo "Creating ER circuit in $hub1_er_pop"
    az network express-route create -n hub1er --peering-location $hub1_er_pop -g $rg \
        --bandwidth 50 Mbps --provider $er_provider -l $location1 --sku-family MeteredData --sku-tier $er_circuit_sku -o none
    service_key_1=$(az network express-route show -n hub1er -g $rg --query serviceKey -o tsv) && echo "Service Key is $service_key_1"
    if [[ "$no_of_hubs" == "2" ]]
    then
        echo "Creating ER gateway in hub2..."
        az network express-route gateway create -g $rg -n hub2ergw --virtual-hub hub2 -l $location2 -o none
        echo "Creating ER circuit in $hub2_er_pop"
        az network express-route create -n hub2er --peering-location $hub2_er_pop -g $rg \
            --bandwidth 50 Mbps --provider $er_provider -l $location2 --sku-family MeteredData --sku-tier $er_circuit_sku -o none
        service_key_2=$(az network express-route show -n hub2er -g $rg --query serviceKey -o tsv) && echo "Service Key is $service_key_2"
    fi
    # Provision Megaport MCR in locations for hub1/hub2 (it could be the same)
    if [[ -e "$megaport_script_location" ]]
    then
        echo "Creating MCR in $hub1_er_pop..."
        $megaport_script_location -q -s=jomore-${hub1_er_pop} -a=create_mcr -k=$service_key_1
        sleep 60  # Wait 1 minute before creating the connections. This could be replaced with a loop checking ./megaport.sh -a=list_live
        echo "Connecting MCR in $hub1_er_pop with ER circuit in hub1..."
        $megaport_script_location -q -s=jomore-${hub1_er_pop} -a=create_vxc -k=$service_key_1
        if [[ "$no_of_hubs" == "2" ]]
        then
            if [[ "$hub1_er_pop" != "$hub2_er_pop" ]]
            then
                echo "Creating MCR in $hub2_er_pop..."
                $megaport_script_location -q -s=jomore-${hub2_er_pop} -a=create_mcr -k=$service_key_2
                sleep 60  # Wait 1 minute before creating the connections. This could be replaced with a loop checking ./megaport.sh -a=list_live
            fi
            echo "Connecting MCR in $hub2_er_pop with ER circuit in hub2..."
            $megaport_script_location -q -s=jomore-${hub2_er_pop} -a=create_vxc -k=$service_key_2
        fi
    else
        echo "Sorry, I cannot seem to find the script $megaport_script_location to interact with the Megaport API"
    fi
    # Wait until circuits are provisioned
    circuit1_id=$(az network express-route show -n hub1er -g $rg -o tsv --query id) && echo "Circuit ID is $circuit1_id"
    circuit1_state=$(az network express-route show -n hub1er -g $rg -o tsv --query serviceProviderProvisioningState) && echo "Circuit state is $circuit1_state"
    echo "Waiting until ER circuit in hub1 is provisioned..."
    until [[ "$circuit1_state" == "Provisioned" ]]
    do
        sleep 15
        circuit1_state=$(az network express-route show -n hub1er -g $rg -o tsv --query serviceProviderProvisioningState) && echo "Circuit state is $circuit1_state_1"
    done
    if [[ "$no_of_hubs" == "2" ]]
    then
        circuit2_id=$(az network express-route show -n hub2er -g $rg -o tsv --query id) && echo "Circuit ID is $circuit2_id"
        circuit2_state=$(az network express-route show -n hub2er -g $rg -o tsv --query serviceProviderProvisioningState) && echo "Circuit state is $circuit2_state"
        echo "Waiting until ER circuit in hub2 is provisioned..."
        until [[ "$circuit2_state" == "Provisioned" ]]
        do
            sleep 15
            circuit2_state=$(az network express-route show -n hub2er -g $rg -o tsv --query serviceProviderProvisioningState) && echo "Circuit state is $circuit_state"
        done
    fi
    # Create connections
    peering_id_1=$(az network express-route peering show -n "AzurePrivatePeering" --circuit-name hub1er -g $rg -o tsv --query id) && echo "Private peering ID is $peering_id_1"
    if [[ -z "$peering_id_1" ]]
    then
        echo "Could not find private peering for ER circuit 1, you might have to refresh in the portal?"
    else
        hub1_default_rt_id=$(az network vhub route-table show --vhub-name hub1 -g $rg -n defaultRouteTable --query id -o tsv) && echo $hub1_default_rt_id
        echo "Connecting branch5 to ER circuit 1..."
        az network vpn-connection create -n "${branch5_gw_name}-${er_pop}-$RANDOM" -g $rg -l $branch5_location --vnet-gateway1 $branch5_gw_name --express-route-circuit2 $circuit1_id -o none
        echo "Connecting VWAN hub1 to ER circuit 1..."
        az network express-route gateway connection create --gateway-name hub1ergw -n "hub1ergw-${hub1_er_pop}" -g $rg --peering $peering_id_1 \
            --associated-route-table $hub1_default_rt_id --propagated-route-tables $hub1_default_rt_id --labels default -o none
    fi
    if [[ "$no_of_hubs" == "2" ]]
    then
        peering_id_2=$(az network express-route peering show -n "AzurePrivatePeering" --circuit-name hub2er -g $rg -o tsv --query id) && echo "Private peering ID is $peering_id_2"
        if [[ -z "$peering_id_2" ]]
        else
            echo "Could not find private peering for ER circuit 2, you might have to refresh in the portal?"
        then
            hub2_default_rt_id=$(az network vhub route-table show --vhub-name hub2 -g $rg -n defaultRouteTable --query id -o tsv) && echo $hub1_default_rt_id
            echo "Connecting branch5 to ER circuit 2..."
            az network vpn-connection create -n "${branch5_gw_name}-${er_pop}-$RANDOM" -g $rg -l $branch5_location --vnet-gateway1 $branch5_gw_name --express-route-circuit2 $circuit2_id -o none
            echo "Connecting VWAN hub2 to ER circuit 2..."
            az network express-route gateway connection create --gateway-name hub2ergw -n "hub2ergw-${hub2_er_pop}" -g $rg --peering $peering_id_2 \
                --associated-route-table $hub2_default_rt_id --propagated-route-tables $hub2_default_rt_id --labels default -o none
        fi
    fi
fi

##############################
#      Routing changes       #
##############################

# Change propagation in all connections. For example:
#   change_prop default
#   change_prop none
function change_prop() {
    hubs=(hub1 hub2)
    for hub in "${hubs[@]}"
    do
        # Change propagation in VNet connections
        if [[ "$1" == "none" ]]; then
            rt_id=$(az network vhub route-table show --vhub-name $hub -g $rg -n noneRouteTable --query id -o tsv)
            label='none'
        else
            rt_id=$(az network vhub route-table show --vhub-name $hub -g $rg -n defaultRouteTable --query id -o tsv)
            label='default'
        fi
        cx_id_list=$(az network vhub connection list -g $rg --vhub-name $hub --query '[].id' -o tsv)
        while IFS= read -r cx_id; do
            echo "Modifying VNet connection ID $cx_id to propagate to ${rt_id}/${label}..."
            az network vhub connection update --ids $cx_id --propagated-route-tables $rt_id --labels $label -o none
        done <<< "$cx_id_list"
        # Get the VPN GW ID and name
        vpngw_id=$(az network vhub show -n $hub -g $rg --query vpnGateway.id -o tsv)
        vpngw_name=$(echo $vpngw_id | cut -d/ -f 9)
        # Change propagation in VPN connections
        vpn_cx_id_list=$(az network vpn-gateway connection list --gateway-name $vpngw_name -g $rg --query '[].id' -o tsv)
        while IFS= read -r cx_id; do
            echo "Modifying VPN connection ID $cx_id to propagate to ${rt_id}/${label}..."
            az network vpn-gateway connection update --ids $cx_id --propagated-route-tables $rt_id --labels $label -o none
        done <<< "$vpn_cx_id_list"
    done
}

##############################
# Connectivity test examples #
##############################

# Set variables
spoke11_pip=$(az network public-ip show -n spoke11-pip -g $rg --query ipAddress -o tsv)
spoke12_pip=$(az network public-ip show -n spoke12-pip -g $rg --query ipAddress -o tsv)
spoke21_pip=$(az network public-ip show -n spoke21-pip -g $rg --query ipAddress -o tsv)
spoke22_pip=$(az network public-ip show -n spoke22-pip -g $rg --query ipAddress -o tsv)
branch1_pip=$(az network public-ip show -n branch1-vm-pip -g $rg --query ipAddress -o tsv)
branch2_pip=$(az network public-ip show -n branch2-vm-pip -g $rg --query ipAddress -o tsv)
csr1_pip=$(az network public-ip show -n branch1-pip -g $rg --query ipAddress -o tsv)
csr2_pip=$(az network public-ip show -n branch2-pip -g $rg --query ipAddress -o tsv)
spoke11_nic_id=$(az vm show -n spoke11-vm -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
spoke12_nic_id=$(az vm show -n spoke12-vm -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
spoke21_nic_id=$(az vm show -n spoke21-vm -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
spoke22_nic_id=$(az vm show -n spoke22-vm -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
branch1_nic_id=$(az vm show -n branch1-vm -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
branch2_nic_id=$(az vm show -n branch2-vm -g "$rg" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
spoke11_ip=$(az network nic show --ids $spoke11_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv)
spoke12_ip=$(az network nic show --ids $spoke12_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv)
spoke21_ip=$(az network nic show --ids $spoke21_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv)
spoke22_ip=$(az network nic show --ids $spoke22_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv)
branch1_ip=$(az network nic show --ids $branch1_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv)
branch2_ip=$(az network nic show --ids $branch2_nic_id --query 'ipConfigurations[0].privateIpAddress' -o tsv)

# Sample connectivity tests
ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $spoke11_pip "ping -c 5 $spoke12_ip"
ssh -n -o BatchMode=yes -o StrictHostKeyChecking=no $spoke11_pip "nc -vz $spoke12_ip 22"
ssh -o StrictHostKeyChecking=no -J $spoke11_pip $spoke12_ip
az network nic show-effective-route-table --ids $branch1_nic_id -o table

##############################
#       Update PC IP         #
##############################

# Updates all route tables with current PC IP
function update_myip() {
    myip=$(curl -s4 ifconfig.co) && echo "Updating backdoor routes to $myip..."
    rt_list=$(az network route-table list -g $rg --query '[].name' -o tsv)
    while IFS= read -r rt_name; do
        echo "Modifying route table $rt_name..."
        az network route-table route update -n mypc --route-table-name $rt_name -g $rg --address-prefix "${myip}/32" -o none
    done <<< "$rt_list"
}
update_myip

######################
# Connection Monitor #
######################

# Get all VMs containing the string "vm" (that excludes the NVAs)
vm_list=$(az vm list -g $rg --query "[?contains(name,'vm')].name" -o tsv | sort -u)
# Build an associative array with all VM IDs
declare -A vm_id_list
echo "Getting VM IDs..."
while IFS= read -r vm_name
do
    vm_id=$(az vm show -g $rg --query id -o tsv -n $vm_name)
    vm_id_list+=([$vm_name]="$vm_id")
done <<< "$vm_list"

# Create connection monitors
while IFS= read -r src_vm
do
    test_name="${src_vm}"
    location=$(az vm show -n $src_vm -g $rg --query location -o tsv)
    monitor_name="${src_vm}-${location}"
    echo "Creating connection monitor for source $src_vm in $location..."
    # The monitor is created with an HTTP config to ubuntu.com
    az network watcher connection-monitor create -n $monitor_name -g $rg -l $location \
        --test-group-name $test_name --endpoint-source-type AzureVM --endpoint-dest-type ExternalAddress \
        --endpoint-source-resource-id "$vm_id_list[$src_vm]" --endpoint-source-name $src_vm \
        --endpoint-dest-address "ubuntu.com" --endpoint-dest-name ubuntucom \
        --test-config-name Http --protocol Http --http-method GET --https-prefer false -o none
    # An ICMP config is added
    echo "Adding ICMP config to connection monitor $monitor_name..."
    az network watcher connection-monitor test-configuration add --connection-monitor $monitor_name -l $location \
        -n Icmp --protocol Icmp --icmp-disable-trace-route false --test-groups $test_name -o none
    # Plus the rest of the VMs are added as targets
    while IFS= read -r dst_vm
    do
        if [[ "$src_vm" != "$dst_vm" ]]
        then
            echo "Adding destination $dst_vm to connection monitor $monitor_name..."
            az network watcher connection-monitor endpoint add --connection-monitor $monitor_name -l $location \
                --resource-id "$vm_id_list[$dst_vm]" --name $dst_vm --type AzureVM --dest-test-groups $test_name -o none
        fi
    done <<< "$vm_list"
done <<< "$vm_list"

# Represents results in table form (configurable interval, default 5m)
function monitor_results() {
    interval=5m
    table_width=12
    if [[ "$location1" == "$location2" ]]
    then
        locations=( $location1 )
    else
        locations=( $location1 $location2 )
    fi
    # Get list of log analytics workspace IDs
    declare -a logws_id_list
    logws_id_list=()
    for location in "${locations[@]}"
    do
        echo "Looking for Network Watcher log analytics workspaces in $location..."
        logws_id_list_location=$(az network watcher connection-monitor list -l $location -o tsv --query '[].outputs[].workspaceSettings.workspaceResourceId')
        logws_id_list_location=$(echo $logws_id_list_location | sort -u)  # Unique values
        if [[ -n "$logws_id_list_location" ]]
        then
            echo "Appending $logws_id_list_location to list of workspaces"
            logws_id_list+=$logws_id_list_location
        else
            echo "No Network Watcher log analytics workspace found in $location"
        fi
    done
    # Remove duplicates (not required any more)
    # logws_id_list=$(echo $(for i in ${logws_id_list[@]}; do echo "$i"; done) | sort -u)
    echo "${#logws_id_list[@]} workspaces found:"
    for logws_id in "${logws_id_list[@]}"; do echo "- $logws_id"; done
    # Get list of log analytics customerIds
    logws_customer_id_list_string=$(for logws_id in "${logws_id_list[@]}"; do logws_rg=$(echo $logws_id | cut -d/ -f 5); logws_name=$(echo $logws_id | cut -d/ -f 9) && az monitor log-analytics workspace show -n $logws_name -g $logws_rg --query customerId -o tsv; done)
    declare -a logws_customer_id_list
    logws_customer_id_list=()
    while IFS= read -r customer_id; do
        logws_customer_id_list+=$customer_id
    done <<< "$logws_customer_id_list_string"
    echo "${#logws_customer_id_list[@]} workspace customer IDs found:"
    for logws_customer_id in "${logws_customer_id_list[@]}"; do echo "- $logws_customer_id"; done
    # Get list of tests, sources and destinations
    echo "Getting sources..."
    src_query="NWConnectionMonitorTestResult | where TimeGenerated > ago(1h) | distinct SourceName"
    src_list=$(for logws_customer_id in "${logws_customer_id_list[@]}"; do az monitor log-analytics query -w $logws_customer_id --analytics-query $src_query --query '[].SourceName' -o tsv; done)
    src_list=$(echo $src_list | sort -u)
    # echo "Source list: $src_list"
    echo "Getting destinations..."
    dst_query="NWConnectionMonitorTestResult | where TimeGenerated > ago(1h) | distinct DestinationName"
    dst_list=$(for logws_customer_id in "${logws_customer_id_list[@]}"; do az monitor log-analytics query -w $logws_customer_id --analytics-query $dst_query --query '[].DestinationName' -o tsv; done)
    dst_list=$(echo $dst_list | sort -u)
    # echo "Destination list: $dst_list"
    echo "Getting test configurations..."
    cfg_query="NWConnectionMonitorTestResult | where TimeGenerated > ago(1h) | distinct TestConfigurationName"
    cfg_list=$(for logws_customer_id in "${logws_customer_id_list[@]}"; do az monitor log-analytics query -w $logws_customer_id --analytics-query $cfg_query --query '[].TestConfigurationName' -o tsv; done)
    cfg_list=$(echo $cfg_list | sort -u)
    # echo "Configuration list: $cfg_list"
    # Get connectivity data with a union query to all workspaces
    if (( ${#logws_customer_id_list[@]} == 1 )); then
        line1='NWConnectionMonitorTestResult'
    else
        line1='union '
        for logws_customer_id in "${logws_customer_id_list[@]}"; do
            if [[ "$line1" != "union " ]]; then
                line1+=', '
            fi
            line1+='workspace("'$logws_customer_id'").NWConnectionMonitorTestResult'
        done
    fi
    line2="| where TimeGenerated > ago($interval) | project SourceName, DestinationName, TestResult, TestConfigurationName | summarize Pass=countif(TestResult == \"Pass\"), NoPass=countif(TestResult != \"Pass\") by SourceName, DestinationName, TestConfigurationName | project PassPercent=Pass/(Pass+NoPass), SourceName, DestinationName, TestConfigurationName"
    query="${line1} ${line2}"
    monitor_json=$(az monitor log-analytics query -w $logws_customer_id --analytics-query $query -o json)
    # For each source, print the latest results to the destination. Do a separate table per configuration test
    cfgs=''
    while IFS= read -r cfg
    do
        if [[ -n "$cfgs" ]]; then
            cfgs+='/'
        fi
        cfgs+="$cfg"
    done <<< "$cfg_list"
    echo " **** Test configurations: $cfgs ****"
    printf "%${table_width}s" "Source"
    while IFS= read -r dst
    do
        printf "%${table_width}s" $dst
    done <<< "$dst_list"
    printf "\n"
    while IFS= read -r src
    do
        printf "%${table_width}s" "$src"
        while IFS= read -r dst
        do
            if [[ "$src" != "$dst" ]]
            then
                # pass_query="NWConnectionMonitorTestResult | where TimeGenerated > ago($interval) | where SourceName==\"$src\" and DestinationName == \"$dst\" and TestConfigurationName == \"$cfg\" | project TestResult | summarize Pass=countif(TestResult == \"Pass\"), NoPass=countif(TestResult != \"Pass\") | project PassPercent=Pass/(Pass+NoPass)"
                # # Browse over the workspaces until something other than "None" arrives
                # pass_percent="None"
                # for logws_customer_id in "${logws_customer_id_list[@]}"
                # do
                #     if [[ "$pass_percent" == "None" ]]
                #     then
                #         # echo "**DEBUG*** Sending query $pass_query to workspace $logws_customer_id..."
                #         pass_percent=$(az monitor log-analytics query -w $logws_customer_id --analytics-query $pass_query --query '[].PassPercent' -o tsv)
                #     fi
                # done
                results=''
                while IFS= read -r cfg
                do
                    if [[ -n "$results" ]]; then
                        results+='/'
                    fi
                    pass_percent=$(echo $monitor_json | jq -r '.[] | select(.SourceName == "'$src'") | select(.DestinationName == "'$dst'") | select(.TestConfigurationName == "'$cfg'") | .PassPercent')
                    if [[ -z "$pass_percent" ]]; then
                        pass_percent='No Data'
                    fi
                    results+="$pass_percent"
                done <<< "$cfg_list"
                printf "%${table_width}s" "$results"
            else
                printf "%${table_width}s" "N/A"
            fi
        done <<< "$dst_list"
        printf "\n"
    done <<< "$src_list"
}
monitor_results

####################################
# Firewall Logs from Azure Monitor #
####################################

# Firewall Network Rules
fw_net_logs_query='AzureDiagnostics
|whereCategory =="AzureFirewallNetworkRule"
| where TimeGenerated >= ago(5m) 
| parse msg_s with Protocol " request from " SourceIP":" SourcePortInt:int" to "TargetIP":"TargetPortInt:int *
| parse msg_s with * ". Action: " Action1a
| parse msg_s with * " was " Action1b " to " NatDestination
| parse msg_s with Protocol2 " request from " SourceIP2" to "TargetIP2". Action: " Action2
| extend SourcePort = tostring(SourcePortInt),TargetPort = tostring(TargetPortInt)
| extend Action = case(Action1a == "", case(Action1b == "",Action2,Action1b), Action1a),Protocol = case(Protocol == "", Protocol2, Protocol),SourceIP = case(SourceIP == "", SourceIP2, SourceIP),TargetIP = case(TargetIP == "", TargetIP2, TargetIP),SourcePort = case(SourcePort == "", "N/A", SourcePort),TargetPort = case(TargetPort == "", "N/A", TargetPort),NatDestination = case(NatDestination == "", "N/A", NatDestination)
//| where Action == "Deny" 
//| project TimeGenerated, msg_s, Protocol, SourceIP,SourcePort,TargetIP,TargetPort,Action, NatDestination  // with msg_s
| project TimeGenerated, Protocol, SourceIP,SourcePort,TargetIP,TargetPort,Action, NatDestination, Resource  // without msg_s
| take 20 '
az monitor log-analytics query -w $logws_customerid --analytics-query $fw_net_logs_query -o tsv
# Firewall App Rules
fw_app_logs_query='AzureDiagnostics 
| where ResourceType == "AZUREFIREWALLS" 
| where Category == "AzureFirewallApplicationRule" 
| where TimeGenerated >= ago(5m) 
| project Protocol=split(msg_s, " ")[0], From=split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",3,4)], To=split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",5,6)], Action=trim_end(".", tostring(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",7,8)])), Rule_Collection=iif(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)]=="traffic.", "AzureInternalTraffic", iif(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)]=="matched.","NoRuleMatched",trim_end(".",tostring(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)])))), Rule=iif(split(msg_s, " ")[11]=="Proceeding" or split(msg_s, " ")[12]=="Proceeding","DefaultAction",split(msg_s, " ")[12]), Resource 
| where Rule_Collection != "AzureInternalTraffic" 
//| where Action == "Deny" 
//| take 20'
az monitor log-analytics query -w $logws_customerid --analytics-query $fw_app_logs_query -o tsv

#################
#  DANGER ZONE  #
#               #
#    Cleanup    #
#################

# az group delete -n $rg -y --no-wait
if [[ "$deploy_er" == "yes" ]]
then
    # Remove MCR from Megaport
    $megaport_script_location -q -s=jomore -a=delete_mcr
fi
# locations=($location1 $location2)
# for location in ${locations[@]}; do
#     monitor_list=$(az network watcher connection-monitor list -l $location --query '[].name' -o tsv)
#     while IFS= read -r monitor_name; do
#         echo "Deleting connection monitor $monitor_name in $location..."
#         az network watcher connection-monitor delete -n $monitor_name -l $location -o none
#     done <<< "$monitor_list"
# done
